//
//  control_surface_integrator.h
//  reaper_control_surface_integrator
//
//

//  Note for Windows environments:
//  use std::byte for C++17 byte
//  use ::byte for Windows byte

#ifndef control_surface_integrator
#define control_surface_integrator

#ifdef _WIN32
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#endif

#include "time.h"
#include <sstream>
#include <vector>
#include <map>
#include <iomanip>
#include <fstream>
#include <regex>
#include <cmath>
#include <memory>
#include <chrono>

#ifdef _WIN32
#include "oscpkt.hh"
#include "udp.hh"
#include <bitset>
#endif

#include "control_surface_integrator_Reaper.h"
#include "WDL/ptrlist.h"
#include "WDL/assocarray.h"

#ifdef _WIN32
#include <functional>
#include "commctrl.h"
#else
#include "oscpkt.hh"
#include "udp.hh"
#endif

#define NUM_ELEM(array) (int(sizeof(array)/sizeof(array[0])))

extern void GetTokens(vector<string> &tokens, string line);
extern int strToHex(const string &valueStr);

extern REAPER_PLUGIN_HINSTANCE g_hInst;

static const string s_CSIName = "CSI";
static const string s_CSIVersionDisplay = "v3.0";
static const string s_MajorVersionToken = "Version 3.0";
static const string s_PageToken = "Page";
static const string s_MidiSurfaceToken = "MidiSurface";
static const string s_OSCSurfaceToken = "OSCSurface";

static const string s_BadFileChars = "[ \\:*?<>|.,()/]";
static const string s_CRLFChars = "[\r\n]";
static const string s_TabChars = "[\t]";
static const string s_BeginAutoSection = "#Begin auto generated section";
static const string s_EndAutoSection = "#End auto generated section";
static const string s_GeneratedByLearn = "Generated by Learn";

class CSIManager;
class ZoneManager;
class Widget;
extern CSIManager *csiManager;
extern bool RemapAutoZoneDialog(ZoneManager *zoneManager, string fullPath);

struct FXParamLayoutTemplate
{
    string modifiers;
    string suffix;
    string widgetAction;
    string aliasDisplayAction;
    string valueDisplayAction ;
    
    FXParamLayoutTemplate()
    {
        modifiers = "";
        suffix = "";
        widgetAction = "";
        aliasDisplayAction = "";
        valueDisplayAction = "";
    }
};

struct FXParamDefinition
{
    vector<string> modifiers;
    int modifier;
    
    string cell;
    
    string paramWidget;
    string paramWidgetFullName;
    string paramNumber;
    map<string, string> paramWidgetProperties;

    string paramNameDisplayWidget;
    string paramNameDisplayWidgetFullName;
    string paramName;
    map<string, string> paramNameDisplayWidgetProperties;
    
    string paramValueDisplayWidget;
    string paramValueDisplayWidgetFullName;
    map<string, string> paramValueDisplayWidgetProperties;

    string delta;
    vector<string> deltas;
    string rangeMinimum;
    string rangeMaximum;
    vector<string> steps;
    vector<string> ticks;
    
    FXParamDefinition()
    {
        modifier = 0;
        cell = "";
        
        paramWidget = "";
        paramWidgetFullName = "";
        paramNumber = "";

        paramNameDisplayWidget = "";
        paramNameDisplayWidgetFullName = "";
        paramName = "";
        
        paramValueDisplayWidget = "";
        paramValueDisplayWidgetFullName = "";
 
        delta = "";
        rangeMinimum = "";
        rangeMaximum = "";
    }
};

struct FXParamDefinitions
{
    vector<FXParamDefinition> definitions;
};

struct AutoZoneDefinition
{
    vector<string> prologue;
    vector<string> epilogue;
    vector<FXParamDefinitions> paramDefs;
    
    vector<string> rawParams;
    map<string, string> rawParamsDictionary;

    string fxName;
    string fxAlias;
    string fullPath;
    
    AutoZoneDefinition()
    {
        fxName = "";
        fxAlias = "";
        fullPath = "";
    }
    
    void Clear()
    {
        prologue.clear();
        epilogue.clear();
        paramDefs.clear();
        
        rawParams.clear();
        rawParamsDictionary.clear();

        fxName = "";
        fxAlias = "";
        fullPath = "";
    }
};

struct LearnFXCell
{
    WDL_PtrList<Widget> fxParamWidgets;
    Widget *fxParamNameDisplayWidget;
    Widget *fxParamValueDisplayWidget;
    
    LearnFXCell()
    {
        fxParamNameDisplayWidget = NULL;
        fxParamValueDisplayWidget = NULL;
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Page;
class ControlSurface;
class Midi_ControlSurface;
class OSC_ControlSurface;
class TrackNavigationManager;
class FeedbackProcessor;
class Zone;
class ActionContext;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Action
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    virtual ~Action() {}
    
    virtual string GetName() { return "Action"; }

    virtual void Touch(ActionContext *context, double value) {}
    virtual void RequestUpdate(ActionContext *context) {}
    virtual void RequestUpdate(ActionContext *context, int paramNum) {}
    virtual void Do(ActionContext *context, double value) {}
    virtual double GetCurrentNormalizedValue(ActionContext *context) { return 0.0; }
    virtual double GetCurrentDBValue(ActionContext *context) { return 0.0; }

    int GetPanMode(MediaTrack *track)
    {
        double pan1, pan2 = 0.0;
        int panMode = 0;
        DAW::GetTrackUIPan(track, &pan1, &pan2, &panMode);
        return panMode;
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Navigator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
protected:
    Page *const page_;
    bool isVolumeTouched_;
    bool isPanTouched_;
    bool isPanWidthTouched_;
    bool isPanLeftTouched_;
    bool isPanRightTouched_;
    bool isMCUTrackPanWidth_;

    Navigator(Page * page) : page_(page)
    {
        // protected:
        isVolumeTouched_ = false;
        isPanTouched_ = false;
        isPanWidthTouched_ = false;
        isPanLeftTouched_ = false;
        isPanRightTouched_ = false;
        isMCUTrackPanWidth_ = false;
    }

public:
    virtual ~Navigator() {}
    
    virtual string GetName() { return "Navigator"; }
    virtual MediaTrack *GetTrack() { return nullptr; }

    bool GetIsNavigatorTouched() { return isVolumeTouched_ || isPanTouched_ || isPanWidthTouched_ || isPanLeftTouched_ || isPanRightTouched_; }
    
    void SetIsVolumeTouched(bool isVolumeTouched) { isVolumeTouched_ = isVolumeTouched;  }
    bool GetIsVolumeTouched() { return isVolumeTouched_;  }
    
    void SetIsPanTouched(bool isPanTouched) { isPanTouched_ = isPanTouched; }
    bool GetIsPanTouched() { return isPanTouched_;  }
    
    void SetIsPanWidthTouched(bool isPanWidthTouched) { isPanWidthTouched_ = isPanWidthTouched; }
    bool GetIsPanWidthTouched() { return isPanWidthTouched_;  }
    
    void SetIsPanLeftTouched(bool isPanLeftTouched) { isPanLeftTouched_ = isPanLeftTouched; }
    bool GetIsPanLeftTouched() { return isPanLeftTouched_;  }
    
    void SetIsPanRightTouched(bool isPanRightTouched) { isPanRightTouched_ = isPanRightTouched; }
    bool GetIsPanRightTouched() { return isPanRightTouched_;  }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class TrackNavigator : public Navigator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    int const channelNum_;
    
protected:
    TrackNavigationManager *const trackNavigationManager_;

public:
    TrackNavigator(Page *page, TrackNavigationManager *trackNavigationManager, int channelNum) : Navigator(page), trackNavigationManager_(trackNavigationManager), channelNum_(channelNum) {}
    virtual ~TrackNavigator() {}
    
    virtual string GetName() override { return "TrackNavigator"; }
   
    virtual MediaTrack *GetTrack() override;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MasterTrackNavigator : public Navigator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    MasterTrackNavigator(Page * page) : Navigator(page) {}
    virtual ~MasterTrackNavigator() {}
    
    virtual string GetName() override { return "MasterTrackNavigator"; }
    
    virtual MediaTrack *GetTrack() override;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class SelectedTrackNavigator : public Navigator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    SelectedTrackNavigator(Page * page) : Navigator(page) {}
    virtual ~SelectedTrackNavigator() {}
    
    virtual string GetName() override { return "SelectedTrackNavigator"; }
    
    virtual MediaTrack *GetTrack() override;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FocusedFXNavigator : public Navigator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    FocusedFXNavigator(Page * page) : Navigator(page) {}
    virtual ~FocusedFXNavigator() {}
    
    virtual string GetName() override { return "FocusedFXNavigator"; }
    
    virtual MediaTrack *GetTrack() override;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class ActionContext
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    Action *const action_;
    Widget  *const widget_;
    Zone  *const zone_;

    vector<string> parameters_;
    
    const vector<string> emptyParameters_;
    
    int intParam_;
    
    string stringParam_;
    
    int paramIndex_;
    string fxParamDisplayName_;
    
    int commandId_;
    
    double rangeMinimum_;
    double rangeMaximum_;
    
    vector<double> steppedValues_;
    int steppedValuesIndex_;
    
    double deltaValue_;
    vector<double> acceleratedDeltaValues_;
    vector<int> acceleratedTickValues_;
    int accumulatedIncTicks_;
    int accumulatedDecTicks_;
    
    bool isValueInverted_;
    bool isFeedbackInverted_;
    double holdDelayAmount_;
    double delayStartTime_;
    double deferredValue_;
    
    bool supportsColor_ = false;
    vector<rgba_color> colorValues_;
    int currentColorIndex_;
    
    bool supportsTrackColor_ = false;
        
    bool provideFeedback_ = false;
    
    map<string, string> widgetProperties_;
    
    // For Learn
    string cellAddress_;
    
    void UpdateTrackColor();

public:
    ActionContext(Action *action, Widget *widget, Zone *zone, const vector<string> &params);
    ActionContext(Action *action, Widget *widget, Zone *zone, int paramIndex) : ActionContext(action, widget, zone, emptyParameters_)
    {
        paramIndex_ = paramIndex;
        
        if (acceleratedTickValues_.size() < 1)
            acceleratedTickValues_.push_back(10);
    }
    ActionContext(Action *action, Widget *widget, Zone *zone, string stringParam) : ActionContext(action, widget, zone, emptyParameters_)
    {
        stringParam_ = stringParam;
        
        if (acceleratedTickValues_.size() < 1)
            acceleratedTickValues_.push_back(10);
    }

    virtual ~ActionContext() {}
    
    Action *GetAction() { return action_; }
    Widget *GetWidget() { return widget_; }
    Zone *GetZone() { return zone_; }
    int GetSlotIndex();
    const string &GetName();

    vector<string> &GetParameters() { return parameters_; }
    
    int GetIntParam() { return intParam_; }
    const string &GetStringParam() { return stringParam_; }
    int GetCommandId() { return commandId_; }
    
    const string &GetFXParamDisplayName() { return fxParamDisplayName_; }
    
    MediaTrack *GetTrack();
    
    void DoRangeBoundAction(double value);
    void DoSteppedValueAction(double value);
    void DoAcceleratedSteppedValueAction(int accelerationIndex, double value);
    void DoAcceleratedDeltaValueAction(int accelerationIndex, double value);
    
    Page *GetPage();
    ControlSurface *GetSurface();
    int GetParamIndex() { return paramIndex_; }
    void SetParamIndex(int paramIndex) { paramIndex_ = paramIndex; }
      
    map<string, string> &GetWidgetProperties() { return widgetProperties_; }
    
    void SetIsValueInverted() { isValueInverted_ = true; }
    void SetIsFeedbackInverted() { isFeedbackInverted_ = true; }
    void SetHoldDelayAmount(double holdDelayAmount) { holdDelayAmount_ = holdDelayAmount  *1000.0; } // holdDelayAmount is specified in seconds, holdDelayAmount_ is in milliseconds
    void SetProvideFeedback(bool provideFeedback) { provideFeedback_ = provideFeedback; }
    
    // For Learn
    void SetCellAddress(string cellAddress) { cellAddress_ = cellAddress; }
    const string &GetCellAddress() { return cellAddress_; }

    void DoAction(double value);
    void DoRelativeAction(double value);
    void DoRelativeAction(int accelerationIndex, double value);
    
    void RequestUpdate();
    void RequestUpdate(int paramNum);
    void RequestUpdateWidgetMode();
    void RunDeferredActions();
    void ClearWidget();
    void UpdateWidgetValue(double value);
    void UpdateJSFXWidgetSteppedValue(double value);
    void UpdateWidgetValue(string value);
    void UpdateColorValue(double value);

    void   SetAccelerationValues(vector<double> acceleratedDeltaValues) { acceleratedDeltaValues_ = acceleratedDeltaValues; }
    void   SetStepSize(double deltaValue) { deltaValue_ = deltaValue; }
    double GetStepSize() { return deltaValue_; }
    void   SetStepValues(vector<double> steppedValues) { steppedValues_ = steppedValues; }
    int    GetNumberOfSteppedValues() { return (int)steppedValues_.size(); }
    void   SetTickCounts(vector<int> acceleratedTickValues) { acceleratedTickValues_ = acceleratedTickValues; }
    
    double GetRangeMinimum() { return rangeMinimum_; }
    double GetRangeMaximum() { return rangeMaximum_; }
    
    void DoTouch(double value)
    {
        action_->Touch(this, value);
    }

    void SetRange(vector<double> range)
    {
        if (range.size() != 2)
            return;
        
        rangeMinimum_ = range[0];
        rangeMaximum_ = range[1];
    }
        
    void SetSteppedValueIndex(double value)
    {
        int index = 0;
        double delta = 100000000.0;
        
        for (int i = 0; i < steppedValues_.size(); i++)
            if (abs(steppedValues_[i] - value) < delta)
            {
                delta = abs(steppedValues_[i] - value);
                index = i;
            }
        
        steppedValuesIndex_ = index;
    }

    const string GetPanValueString(double panVal, const string &dualPan)
    {
        bool left = false;
        
        if (panVal < 0)
        {
            left = true;
            panVal = -panVal;
        }
        
        int panIntVal = int(panVal  *100.0);
        string trackPanValueString = "";
        
        if (left)
        {
            if (panIntVal == 100)
                trackPanValueString += "<";
            else if (panIntVal < 100 && panIntVal > 9)
                trackPanValueString += "< ";
            else
                trackPanValueString += "<  ";
            
            trackPanValueString += to_string(panIntVal);
            
            if (dualPan != "")
                trackPanValueString += dualPan;
        }
        else
        {
            if (dualPan == "")
                trackPanValueString += "   ";
            else
                trackPanValueString += "  " + dualPan;
            
            trackPanValueString += to_string(panIntVal);
            
            if (panIntVal == 100)
                trackPanValueString += ">";
            else if (panIntVal < 100 && panIntVal > 9)
                trackPanValueString += " >";
            else
                trackPanValueString += "  >";
        }
        
        if (panIntVal == 0)
        {
            if (dualPan == "")
                trackPanValueString = "  <C>  ";
            if (dualPan == "L")
                trackPanValueString = " L<C>  ";
            if (dualPan == "R")
                trackPanValueString = " <C>R  ";

        }

        return trackPanValueString;
    }
    
    string GetPanWidthValueString(double widthVal)
    {
        bool reversed = false;
        
        if (widthVal < 0)
        {
            reversed = true;
            widthVal = -widthVal;
        }
        
        int widthIntVal = int(widthVal  *100.0);
        string trackPanWidthString = "";
        
        if (! reversed)
            trackPanWidthString += "Wid ";
        else
            trackPanWidthString += "Rev ";
        
        trackPanWidthString += to_string(widthIntVal);
        
        if (widthIntVal == 0)
            trackPanWidthString = "<Mono> ";

        return trackPanWidthString;
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Zone
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    ZoneManager  *const zoneManager_;
protected:
    Navigator *const navigator_;
    int slotIndex_;
    string const name_;
    string const alias_;
    string const sourceFilePath_;
    
    bool isActive_;
public:
    bool gcState_; // used by ZoneManager::GarbageCollectZones and Zone::GCTagZone
protected:
    
    // these do not own the widgets, ultimately the ControlSurface contains the list of widgets
    WDL_PointerKeyedArray<Widget*, bool> widgets_; 
    WDL_StringKeyedArray<Widget*> widgetsByName_;
    
    map<int, map<string, LearnFXCell>> learnFXCells_;
    LearnFXCell emptyLearnFXCell_ = LearnFXCell();
    
    WDL_PtrList<Zone> includedZones_;
    map<string, WDL_PtrList<Zone> > subZones_;
    map<string, WDL_PtrList<Zone> > associatedZones_;
    
    WDL_PtrList<ActionContext> actionContextNeedFree_; // owns the ActionContext, frees on destroy
    map<Widget*, map<int, WDL_PtrList<ActionContext> > > actionContextDictionary_;
    WDL_PtrList<ActionContext> empty_;
    map<Widget*, int> currentActionContextModifiers_;
    WDL_PtrList<ActionContext> defaultContexts_;
    
    void AddNavigatorsForZone(const string &zoneName, WDL_PtrList<Navigator> &navigators);
    void UpdateCurrentActionContextModifier(Widget *widget);
        
public:
    Zone(ZoneManager  *const zoneManager, Navigator *navigator, int slotIndex, string name, string alias, string sourceFilePath, vector<string> includedZones, vector<string> associatedZones);
    
    virtual ~Zone() {
        actionContextNeedFree_.Empty(true);
    }
    
    void InitSubZones(const vector<string> &subZones, Zone *enclosingZone);
    void GoAssociatedZone(const string &associatedZoneName);
    void GoAssociatedZone(const string &associatedZoneName, int slotIndex);
    void ReactivateFXMenuZone();
    int GetSlotIndex();
    int GetParamIndex(const string &widgetName);
    void SetXTouchDisplayColors(const string &color);
    void RestoreXTouchDisplayColors();
    void UpdateCurrentActionContextModifiers();
    const WDL_PtrList<ActionContext> &GetActionContexts(Widget *widget);
    void Activate();
    void Deactivate();
    void DoAction(Widget *widget, bool &isUsed, double value);
    int GetChannelNumber();
    void RequestLearnFXUpdate(map<Widget*, bool> &usedWidgets);
    void SetFXParamNum(Widget *paramWidget, int paramIndex);

    const string &GetSourceFilePath() { return sourceFilePath_; }
    
    virtual string GetType() { return "Zone"; }
    
    const WDL_PointerKeyedArray<Widget*, bool> &GetWidgets() { return widgets_; }

    Navigator *GetNavigator() { return navigator_; }
    void SetSlotIndex(int index) { slotIndex_ = index; }
    bool GetIsActive() { return isActive_; }

    const map<int, map<string, LearnFXCell>> &GetLearnFXCells() { return learnFXCells_; }
    
    int GetModifier(Widget *widget)
    {
        int modifier = 0;
        
        if (currentActionContextModifiers_.count(widget) > 0 )
            modifier = currentActionContextModifiers_[widget];

        return modifier;
    }
    
    void AddLearnFXCell(int modifier, const string &cellAddress, LearnFXCell cell)
    {
        learnFXCells_[modifier][cellAddress] = cell;
    }
    
    const LearnFXCell &GetLearnFXCell(int modifier, const string &cellAddress)
    {
        if (learnFXCells_.count(modifier) > 0 && learnFXCells_[modifier].count(cellAddress) > 0)
            return learnFXCells_[modifier][cellAddress];
        else return emptyLearnFXCell_;
    }
    
    Zone *GetLearnFXParamsZone()
    {
        if (associatedZones_.count("LearnFXParams") && associatedZones_["LearnFXParams"].GetSize() == 1)
            return associatedZones_["LearnFXParams"].Get(0);
        else
            return NULL;
    }
       
    Zone *GetFXLayoutZone(const string &name)
    {
        if (associatedZones_.count(name) && associatedZones_[name].GetSize() == 1)
            return associatedZones_[name].Get(0);
        else
            return NULL;
    }
       
    bool GetIsMainZoneOnlyActive()
    {
        for (auto [key, zones] : associatedZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                if (zones.Get(i)->GetIsActive())
                    return false;
        
        return true;
    }
    
    bool GetIsAssociatedZoneActive(const string &zoneName)
    {
        if (associatedZones_.count(zoneName) > 0)
            for (int i = 0; i < associatedZones_[zoneName].GetSize(); ++i)
                if (associatedZones_[zoneName].Get(i)->GetIsActive())
                    return true;
        
        return false;
    }

    void Toggle()
    {
        if (isActive_)
            Deactivate();
        else
            Activate();
    }

    const string &GetName()
    {
        return name_;
    }
    
    const string &GetNameOrAlias()
    {
        if (alias_ != "")
            return alias_;
        else
            return name_;
    }
    
    void AddWidget(Widget *widget, const string &name)
    {
        widgets_.Insert(widget, true);
        widgetsByName_.Insert(name.c_str(), widget);
    }
    
    Widget *GetWidgetByName(const string &name)
    {
        return widgetsByName_.Get(name.c_str());
    }
    
    void AddActionContext(Widget *widget, int modifier, ActionContext *actionContext)
    {
        actionContextDictionary_[widget][modifier].Add(actionContext);
        actionContextNeedFree_.Add(actionContext);
    }
    
    const WDL_PtrList<ActionContext> &GetActionContexts(Widget *widget, int modifier)
    {
        if (actionContextDictionary_.count(widget) > 0 && actionContextDictionary_[widget].count(modifier) > 0)
            return actionContextDictionary_[widget][modifier];
        else
            return empty_;
    }
    
    virtual void GoSubZone(const string &subZoneName)
    {
        if (subZones_.count(subZoneName) > 0)
        {
            for (int i = 0; i < subZones_[subZoneName].GetSize(); ++i)
            {
                subZones_[subZoneName].Get(i)->SetSlotIndex(GetSlotIndex());
                subZones_[subZoneName].Get(i)->Activate();
            }
        }
    }
    
    void OnTrackDeselection()
    {
        isActive_ = true;
        
        for (int i = 0; i < includedZones_.GetSize(); ++i)
            includedZones_.Get(i)->Activate();
       
        for (auto &[key, zones] : associatedZones_)
            if (key == "SelectedTrack" || key == "SelectedTrackSend" || key == "SelectedTrackReceive" || key == "SelectedTrackFXMenu")
                for (int i = 0; i < zones.GetSize(); ++i)
                    zones.Get(i)->Deactivate();
    }

    void RequestUpdateWidget(Widget *widget)
    {
        for (int i = 0; i < GetActionContexts(widget).GetSize(); ++i)
        {
            GetActionContexts(widget).Get(i)->RunDeferredActions();
            GetActionContexts(widget).Get(i)->RequestUpdate();
        }
    }

    void RequestUpdate(map<Widget*, bool> &usedWidgets)
    {
        if (! isActive_)
            return;
      
        for (const auto &[key, zones] : subZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                zones.Get(i)->RequestUpdate(usedWidgets);
        
        for (const auto &[key, zones] : associatedZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                zones.Get(i)->RequestUpdate(usedWidgets);

        for (int i =  0; i < includedZones_.GetSize(); ++i)
            includedZones_.Get(i)->RequestUpdate(usedWidgets);
        
        for (int i = 0; i < widgets_.GetSize(); i ++)
        {
            Widget *widget = NULL;
            widgets_.EnumeratePtr(i,&widget);
            if (WDL_NORMALLY(widget) && usedWidgets[widget] == false)
            {
                usedWidgets[widget] = true;
                RequestUpdateWidget(widget);
            }
        }
    }

    void DoRelativeAction(Widget *widget, bool &isUsed, double delta)
    {
        if (! isActive_ || isUsed)
            return;
        
        for (const auto &[key, zones] : subZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                zones.Get(i)->DoRelativeAction(widget, isUsed, delta);

        for (const auto &[key, zones] : associatedZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                zones.Get(i)->DoRelativeAction(widget, isUsed, delta);

        if (isUsed)
            return;

        if (widgets_.Exists(widget))
        {
            isUsed = true;

            for (int i = 0; i < GetActionContexts(widget).GetSize(); ++i)
                GetActionContexts(widget).Get(i)->DoRelativeAction(delta);
        }
        else
        {
            for (int i = 0; i < includedZones_.GetSize(); ++i)
                includedZones_.Get(i)->DoRelativeAction(widget, isUsed, delta);
        }
    }

    void DoRelativeAction(Widget *widget, bool &isUsed, int accelerationIndex, double delta)
    {
        if (! isActive_ || isUsed)
            return;

        for (const auto &[key, zones] : subZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                zones.Get(i)->DoRelativeAction(widget, isUsed, accelerationIndex, delta);
        
        for (const auto &[key, zones] : associatedZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                zones.Get(i)->DoRelativeAction(widget, isUsed, accelerationIndex, delta);

        if (isUsed)
            return;

        if (widgets_.Exists(widget))
        {
            isUsed = true;

            for (int i = 0; i < GetActionContexts(widget).GetSize(); ++i)
                GetActionContexts(widget).Get(i)->DoRelativeAction(accelerationIndex, delta);
        }
        else
        {
            for (int i = 0; i < includedZones_.GetSize(); ++i)
                includedZones_.Get(i)->DoRelativeAction(widget, isUsed, accelerationIndex, delta);
        }
    }

    void DoTouch(Widget *widget, string widgetName, bool &isUsed, double value)
    {
        if (! isActive_ || isUsed)
            return;

        for (const auto &[key, zones] : subZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                zones.Get(i)->DoTouch(widget, widgetName, isUsed, value);
        
        for (const auto &[key, zones] : associatedZones_)
            for (int i = 0; i < zones.GetSize(); ++i)
                zones.Get(i)->DoTouch(widget, widgetName, isUsed, value);

        if (isUsed)
            return;

        if (widgets_.Exists(widget))
        {
            isUsed = true;

            for (int i = 0; i < GetActionContexts(widget).GetSize(); ++i)
                GetActionContexts(widget).Get(i)->DoTouch(value);
        }
        else
        {
            for (int i = 0; i < includedZones_.GetSize(); ++i)
                includedZones_.Get(i)->DoTouch(widget, widgetName, isUsed, value);
        }
    }
    static void GCTagZone(Zone *zone);
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class SubZone : public Zone
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    Zone  *const enclosingZone_;
    
public:
    SubZone(ZoneManager  *const zoneManager, Navigator *navigator, int slotIndex, string name, string alias, string sourceFilePath, vector<string> includedZones, vector<string> associatedZones, Zone *enclosingZone) : Zone(zoneManager, navigator, slotIndex, name, alias, sourceFilePath, includedZones, associatedZones), enclosingZone_(enclosingZone) {}

    virtual ~SubZone() {}
    
    virtual string GetType() override { return "SubZone"; }

    virtual void GoSubZone(const string &subZoneName) override
    {
        Deactivate();
        enclosingZone_->GoSubZone(subZoneName);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Widget
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    ControlSurface *const surface_;
    string const name_;
    WDL_PtrList<FeedbackProcessor> feedbackProcessors_; // owns the objects
    int channelNumber_;
    double lastIncomingMessageTime_;
       
    double stepSize_;
    vector<double> accelerationValues_;
    
public:
    // all Widges are owned by their ControlSurface!
    Widget(ControlSurface *surface, const string &name) : surface_(surface), name_(name)
    {
        // private:
        channelNumber_ = 0;
        lastIncomingMessageTime_ = 0.0;
        stepSize_ = 0.0;

        int index = (int)name.length() - 1;
        if (isdigit(name[index]))
        {
            while (isdigit(name[index]))
                index--;
               
            index++;
            
            channelNumber_ = stoi(name.substr(index, name.length() - index));
        }
    }
    ~Widget()
    {
      feedbackProcessors_.Empty(true);
    }
    
    const string &GetName() { return name_; }
    ControlSurface *GetSurface() { return surface_; }
    ZoneManager *GetZoneManager();
    int GetChannelNumber() { return channelNumber_; }
    
    void SetStepSize(double stepSize) { stepSize_ = stepSize; }
    double GetStepSize() { return stepSize_; }
    
    void SetAccelerationValues( vector<double> accelerationValues) { accelerationValues_ = accelerationValues; }
    vector<double> &GetAccelerationValues() { return accelerationValues_; }
    
    void SetIncomingMessageTime(double lastIncomingMessageTime) { lastIncomingMessageTime_ = lastIncomingMessageTime; }
    double GetLastIncomingMessageTime() { return lastIncomingMessageTime_; }
    
    void Configure(const WDL_PtrList<ActionContext> &contexts);
    void UpdateValue(map<string, string> &properties, double value);
    void UpdateValue(map<string, string> &properties, string value);
    void RunDeferredActions();
    void UpdateColorValue(rgba_color);
    void SetXTouchDisplayColors(const string &zoneName, const string &colors);
    void RestoreXTouchDisplayColors();
    void ForceClear();
    void LogInput(double value);
    
    void AddFeedbackProcessor(FeedbackProcessor *feedbackProcessor) // takes ownership of feedbackProcessor
    {
        feedbackProcessors_.Add(feedbackProcessor);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct CSIZoneInfo
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
    string filePath;
    string alias;
    
    CSIZoneInfo()
    {
        filePath = "";
        alias = "";
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct CSILayoutInfo
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
    string modifiers;
    string suffix;
    int channelCount;
    
    CSILayoutInfo()
    {
        modifiers = "";
        suffix = "";
        channelCount = 0;
    }
    
    vector<string> GetModifierTokens()
    {
        istringstream modifierStr(modifiers);
        string modifier;
        vector<string> modifiers;
        
        while (getline(modifierStr, modifier, '+'))
            modifiers.push_back(modifier);
         
        modifiers.push_back("");

        return modifiers;
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct LearnInfo
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
    Widget  *const fxParamWidget;
    string const cellAddress = "";
    
    bool isLearned;
    int paramNumber;
    string paramName;
    string params;
    MediaTrack *track;
    int fxSlotNum;
    
    LearnInfo(Widget *paramWidget, string cellAddress) : fxParamWidget(paramWidget), cellAddress(cellAddress)
    {
        isLearned = false;
        paramNumber = 0;
        paramName = "";
        params = "";
        track = nullptr;
        fxSlotNum = 0;

    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class ZoneManager
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    ControlSurface *const surface_;
    string const zoneFolder_;
    string const fxZoneFolder_;

    map<string, CSIZoneInfo> zoneFilePaths_;
    
    map<Widget*, bool> usedWidgets_;
    
    Zone *noMapZone_;
    
    Zone *homeZone_;
    
    map<int, map<Widget*, Widget*>> controlDisplayAssociations_;
    vector<string> fxLayoutFileLines_;
    vector<string> fxLayoutFileLinesOriginal_;
    Zone *fxLayout_;
    vector<vector<string>> surfaceFXLayout_;
    vector<vector<string>> surfaceFXLayoutTemplate_;
    vector<CSILayoutInfo> fxLayouts_;
    vector<string> fxPrologue_;
    vector<string> fxEpilogue_;
    
    WDL_PtrList<ZoneManager> listeners_;
    
    bool listensToGoHome_;
    bool listensToSends_;
    bool listensToReceives_;
    bool listensToFocusedFX_;
    bool listensToFocusedFXParam_;
    bool listensToFXMenu_;
    bool listensToLocalFXSlot_;
    bool listensToSelectedTrackFX_;
    bool listensToCustom_;

    bool needGarbageCollect_;

    Zone *focusedFXParamZone_;
    bool isFocusedFXParamMappingEnabled_;
    
    map<int, map<int, int>> focusedFXDictionary_;
    WDL_PtrList<Zone> focusedFXZones_;
    bool isFocusedFXMappingEnabled_;
    
    WDL_PtrList<Zone> selectedTrackFXZones_;
    WDL_PtrList<Zone> fxSlotZones_;
    
    map <string, map<int, vector<double>>> steppedValues_;
    
    int trackSendOffset_;
    int trackReceiveOffset_;
    int trackFXMenuOffset_;
    int selectedTrackSendOffset_;
    int selectedTrackReceiveOffset_;
    int selectedTrackFXMenuOffset_;
    int masterTrackFXMenuOffset_;
    
    string learnFXName_;
    LearnInfo *lastTouched_;

    AutoZoneDefinition zoneDef_;
    vector<string> paramList_;
    map<Widget*, map<int, LearnInfo*>> learnedFXParams_;

    void CalculateSteppedValues(const string &fxName, MediaTrack *track, int fxIndex);

    void AdjustBank(int &bankOffset, int amount)
    {
        bankOffset += amount;
            
        if (bankOffset < 0)
            bankOffset = 0;
    }
    
    void ResetOffsets()
    {
        trackSendOffset_ = 0;
        trackReceiveOffset_ = 0;
        trackFXMenuOffset_ = 0;
        selectedTrackSendOffset_ = 0;
        selectedTrackReceiveOffset_ = 0;
        selectedTrackFXMenuOffset_ = 0;
        masterTrackFXMenuOffset_ = 0;
    }
    
    void ResetSelectedTrackOffsets()
    {
        selectedTrackSendOffset_ = 0;
        selectedTrackReceiveOffset_ = 0;
        selectedTrackFXMenuOffset_ = 0;
    }
      
    void GoFXSlot(MediaTrack *track, Navigator *navigator, int fxSlot);
    void GoSelectedTrackFX();
    void InitializeFXParamsLearnZone();
    void InitializeNoMapZone();
    void GetExistingZoneParamsForLearn(const string &fxName, MediaTrack *track, int fxSlotNum);
    void GetWidgetNameAndModifiers(const string &line, int listSlotIndex, string &cell, string &paramWidgetName, string &paramWidgetFullName, vector<string> &modifiers, int &modifier, vector<FXParamLayoutTemplate> &layoutTemplates);
    int GetModifierValue(const vector<string> &modifiers);

    void GoLearnFXParams()
    {
        int trackNumber = 0;
        int itemNumber = 0;
        int fxSlot = 0;
        MediaTrack *track = nullptr;
        
        if (DAW::GetFocusedFX2(&trackNumber, &itemNumber, &fxSlot) == 1)
        {
            if (trackNumber > 0)
                track = DAW::GetTrack(trackNumber);
            
            if (track)
            {
                char fxName[BUFSZ];
                DAW::TrackFX_GetFXName(track, fxSlot, fxName, sizeof(fxName));
                learnFXName_ = fxName;
                
                GoLearnFXParams(track, fxSlot);
            }
        }
    }
    
    bool GetIsListener()
    {
        return listensToGoHome_ || listensToSends_ || listensToReceives_ || listensToFocusedFX_ || listensToFocusedFXParam_ || listensToFXMenu_ || listensToLocalFXSlot_ || listensToSelectedTrackFX_;
    }

    void DeclareGoSelectedTrackSend(const string &zoneName)
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
        {
            if (homeZone_ != nullptr)
            {
                ClearFXMapping();
                ResetOffsets();
                        
                homeZone_->GoAssociatedZone(zoneName);
            }
        }
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToGoSelectedTrackSend(zoneName);
    }
    
    void DeclareGoSelectedTrackReceive(const string &zoneName)
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
        {
            if (homeZone_ != nullptr)
            {
                ClearFXMapping();
                ResetOffsets();
                        
                homeZone_->GoAssociatedZone(zoneName);
            }
        }
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToGoSelectedTrackReceive(zoneName);
    }
  
    void DeclareGoSelectedTrackFX()
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
            GoSelectedTrackFX();
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToGoSelectedTrackFX();
    }
        
    void DeclareGoCustom(const string &zoneName)
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
        {
            if (homeZone_ != nullptr)
            {
                ClearFXMapping();
                ResetOffsets();
                        
                homeZone_->GoAssociatedZone(zoneName);
            }
        }
        else
            for (int i = 0; i < (int)listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToGoCustom(zoneName);
    }
    
    void ListenToGoHome()
    {
        if (listensToGoHome_)
            GoHome();
    }
    
    void ListenToGoSelectedTrackSend(const string &zoneName)
    {
        if (listensToSends_)
        {
            if (homeZone_ != nullptr)
            {
                ClearFXMapping();
                ResetOffsets();
                        
                homeZone_->GoAssociatedZone(zoneName);
            }
        }
    }

    void ListenToGoSelectedTrackReceive(const string &zoneName)
    {
        if (listensToReceives_)
        {
            if (homeZone_ != nullptr)
            {
                ClearFXMapping();
                ResetOffsets();
                        
                homeZone_->GoAssociatedZone(zoneName);
            }
        }
    }
    
    void ListenToGoCustom(const string &zoneName)
    {
        if (listensToCustom_)
        {
            if (homeZone_ != nullptr)
            {
                ClearFXMapping();
                ResetOffsets();
                        
                homeZone_->GoAssociatedZone(zoneName);
            }
        }
    }
        
    void DeclareGoSelectedTrackFXMenu(const string &zoneName)
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
        {
            if (homeZone_ != nullptr)
            {
                ClearFXMapping();
                ResetOffsets();
                        
                homeZone_->GoAssociatedZone(zoneName);
            }
        }
        else
            for (int i = 0; i < (int)listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToGoSelectedTrackFXMenu(zoneName);
    }
    
    void ListenToGoSelectedTrackFXMenu(const string &zoneName)
    {
        if (listensToFXMenu_)
        {
            if (homeZone_ != nullptr)
            {
                ClearFXMapping();
                ResetOffsets();
                        
                homeZone_->GoAssociatedZone(zoneName);
            }
        }
    }
    
    void ListenToGoFXSlot(MediaTrack *track, Navigator *navigator, int fxSlot)
    {
        if (listensToFXMenu_)
            GoFXSlot(track, navigator, fxSlot);
    }
    
    void ListenToClearFXSlot(Zone *zone)
    {
       if (listensToFXMenu_)
           ClearFXSlot(zone);
    }
            
    void ListenToGoSelectedTrackFX()
    {
       if (listensToSelectedTrackFX_)
           GoSelectedTrackFX();
    }
    
    void ListenToClearSelectedTrackFX()
    {
       if (listensToSelectedTrackFX_)
           ClearSelectedTrackFX();
    }
    
    void ListenToClearFocusedFXParam()
    {
       if (listensToFocusedFXParam_)
           ClearFocusedFXParam();
    }
    
    void ListenToToggleEnableFocusedFXParamMapping()
    {
        if (listensToFocusedFXParam_)
            ToggleEnableFocusedFXParamMapping();
    }

    void ToggleEnableFocusedFXParamMapping()
    {
        isFocusedFXParamMappingEnabled_ = ! isFocusedFXParamMappingEnabled_;
        
        if (focusedFXParamZone_ != nullptr)
        {
            if (isFocusedFXParamMappingEnabled_)
                focusedFXParamZone_->Activate();
            else
                focusedFXParamZone_->Deactivate();
        }
    }

    void ListenToClearFocusedFX()
    {
       if (listensToFocusedFX_)
           ClearFocusedFX();
    }

    void ListenToToggleEnableFocusedFXMapping()
    {
        if (listensToFocusedFX_)
            ToggleEnableFocusedFXMapping();
    }

    void ToggleEnableFocusedFXMapping()
    {
        isFocusedFXMappingEnabled_ = ! isFocusedFXMappingEnabled_;
    }

    void ClearFocusedFXParam()
    {
        if (focusedFXParamZone_ != nullptr)
        {
            focusedFXParamZone_->Deactivate();
            focusedFXParamZone_ = nullptr;
        }
    }
    
    void ClearFocusedFX()
    {
        for (int i = 0; i < focusedFXZones_.GetSize(); ++i)
            focusedFXZones_.Get(i)->Deactivate();
        
        focusedFXZones_.Empty();
        focusedFXDictionary_.clear();

        needGarbageCollect_ = true;
    }
        
    void ClearSelectedTrackFX()
    {
        for (int i = 0; i < (int)selectedTrackFXZones_.GetSize(); ++i)
            selectedTrackFXZones_.Get(i)->Deactivate();
        
        selectedTrackFXZones_.Empty();

        needGarbageCollect_ = true;
    }
    
    void ClearFXSlot(Zone *zone)
    {
        for (int i = 0; i < fxSlotZones_.GetSize(); i++)
        {
            if (fxSlotZones_.Get(i)->GetName() == zone->GetName() && fxSlotZones_.Get(i)->GetSlotIndex() == zone->GetSlotIndex())
            {
                fxSlotZones_.Get(i)->Deactivate();
                fxSlotZones_.Delete(i);
                if (homeZone_ != nullptr)
                    homeZone_->ReactivateFXMenuZone();
                needGarbageCollect_ = true;
                break;
            }
        }
    }

    void GetProperties(int start, int finish, vector<string> &tokens, map<string, string> &properties)
    {
        for (int i = start; i < finish; i++)
        {
            if (tokens[i].find("=") != string::npos)
            {
                istringstream property(tokens[i]);
                vector<string> kvp;
                string token;
                
                while (getline(property, token, '='))
                    kvp.push_back(token);

                if (kvp.size() == 2)
                    properties[kvp[0]] = kvp[1];
            }
        }
    }

    void GetSteppedValues(vector<string> &params, string &deltaValue, vector<string> &acceleratedDeltaValues, string &rangeMinimum, string &rangeMaximum, vector<string> &steppedValues, vector<string> &acceleratedTickValues)
    {
        vector<string>::iterator openSquareBrace = find(params.begin(), params.end(), "[");
        vector<string>::iterator closeSquareBrace = find(params.begin(), params.end(), "]");
        
        if (openSquareBrace != params.end() && closeSquareBrace != params.end())
        {
            for (vector<string>::iterator it = openSquareBrace + 1; it != closeSquareBrace; ++it)
            {
                string strVal = *(it);
                
                if (regex_match(strVal, regex("-?[0-9]+[.][0-9]+")) || regex_match(strVal, regex("-?[0-9]+")))
                    steppedValues.push_back(strVal);
                else if (regex_match(strVal, regex("[(]-?[0-9]+[.][0-9]+[)]")))
                    deltaValue = regex_replace(strVal, regex("[()]"), "");
                else if (regex_match(strVal, regex("[(]-?[0-9]+[)]")))
                    acceleratedTickValues.push_back(strVal);
                else if (regex_match(strVal, regex("[(](-?[0-9]+[.][0-9]+[,])+-?[0-9]+[.][0-9]+[)]")))
                {
                    istringstream acceleratedDeltaValueStream(strVal);
                    string deltaValue;
                    
                    while (getline(acceleratedDeltaValueStream, deltaValue, ','))
                        acceleratedDeltaValues.push_back(regex_replace(deltaValue, regex("[()]"), "") + "  ");
                }
                else if (regex_match(strVal, regex("[(](-?[0-9]+[,])+-?[0-9]+[)]")))
                {
                    istringstream acceleratedTickValueStream(strVal.substr( 1, strVal.length() - 2 ));
                    string tickValue;
                    
                    while (getline(acceleratedTickValueStream, tickValue, ','))
                        acceleratedTickValues.push_back(tickValue + "  ");
                }
                else if (regex_match(strVal, regex("-?[0-9]+[.][0-9]+[>]-?[0-9]+[.][0-9]+")) || regex_match(strVal, regex("[0-9]+[-][0-9]+")))
                {
                    istringstream range(strVal);
                    vector<string> range_tokens;
                    string range_token;
                    
                    while (getline(range, range_token, '>'))
                        range_tokens.push_back(range_token);
                    
                    if (range_tokens.size() == 2)
                    {
                        string firstValue = range_tokens[0];
                        string lastValue = range_tokens[1];
                        
                        if (lastValue > firstValue)
                        {
                            rangeMinimum = firstValue;
                            rangeMaximum = lastValue;
                        }
                        else
                        {
                            rangeMinimum = lastValue;
                            rangeMaximum = firstValue;
                        }
                    }
                }
            }
        }
    }

    void GetAlias(const char *fxName, string &alias)
    {
        static const char  *const prefixes[] =
        {
            "AU: Tube-Tech ",
            "AU: AU ",
            "AU: UAD UA ",
            "AU: UAD Pultec ",
            "AU: UAD Tube-Tech ",
            "AU: UAD Softube ",
            "AU: UAD Teletronix ",
            "AU: UADx ",
            "AU: UAD ",
            "AU: ",
            "AUi: ",
            "VST: TDR ",
            "VST: UAD UA ",
            "VST: UAD Pultec ",
            "VST: UAD Tube-Tech ",
            "VST: UAD Softube ",
            "VST: UAD Teletronix ",
            "VST: UAD ",
            "VST3: UADx ",
            "VST3i: UADx ",
            "VST: ",
            "VSTi: ",
            "VST3: ",
            "VST3i: ",
            "JS: ",
            "Rewire: ",
            "CLAP: ",
            "CLAPi: ",
        };
        
        // skip over known prefixes
        for (int i = 0; i < NUM_ELEM(prefixes); ++i)
        {
            const int l = (int) strlen(prefixes[i]);
            if (!strncmp(fxName, prefixes[i], l))
            {
                fxName += l;
                break;
            }
        }

        alias = fxName;
        const int ml = alias.find(" (");
        if (ml > 0) alias.resize(ml);
    }

public:
    ZoneManager(ControlSurface *surface, const string &zoneFolder, const string &fxZoneFolder) : surface_(surface), zoneFolder_(zoneFolder), fxZoneFolder_(fxZoneFolder)
    {
        //private:
        noMapZone_ = NULL;
        homeZone_ = NULL;
        fxLayout_ = NULL;
        focusedFXParamZone_ = NULL;
        
        listensToGoHome_ = false;
        listensToSends_ = false;
        listensToReceives_ = false;
        listensToFocusedFX_ = false;
        listensToFocusedFXParam_ = false;
        listensToFXMenu_ = false;
        listensToLocalFXSlot_ = false;
        listensToSelectedTrackFX_ = false;
        listensToCustom_ = false;

        needGarbageCollect_ = false;

        isFocusedFXParamMappingEnabled_ = false;
        
        isFocusedFXMappingEnabled_ = true;
        
        trackSendOffset_ = 0;
        trackReceiveOffset_ = 0;
        trackFXMenuOffset_ = 0;
        selectedTrackSendOffset_ = 0;
        selectedTrackReceiveOffset_ = 0;
        selectedTrackFXMenuOffset_ = 0;
        masterTrackFXMenuOffset_ = 0;
        
        learnFXName_ = "";
        lastTouched_ = nullptr;
    }

    ~ZoneManager()
    {
        for (auto [key, learnedFXParamsForModifier] : learnedFXParams_)
            for (auto [key, learnedFXParam] : learnedFXParamsForModifier)
                delete learnedFXParam;

        allZonesNeedFree_.Empty(true);
    }
        
    void Initialize();
    
    void PreProcessZones();
        
    Navigator *GetMasterTrackNavigator();
    Navigator *GetSelectedTrackNavigator();
    Navigator *GetFocusedFXNavigator();
    
    bool GetIsBroadcaster() { return  ! (listeners_.GetSize() == 0); }
    void AddListener(ControlSurface *surface);
    void SetListenerCategories(const string &categoryList);
    const WDL_PtrList<ZoneManager> &GetListeners() { return listeners_; }
    
    int  GetNumChannels();
    void GoFocusedFX();
    void CalculateSteppedValue(const string &fxName, MediaTrack *track, int fxIndex, int paramIndex);
    void AutoMapFX(const string &fxName, MediaTrack *track, int fxIndex);
    void RemapAutoZone();
    void UpdateCurrentActionContextModifiers();
    void CheckFocusedFXState();

    void GoFXLayoutZone(const string &zoneName, int slotIndex);
    void WidgetMoved(ActionContext *context);
    void SetParamNum(Widget *widget, int fxParamNum);

    void DoLearn(ActionContext *context, double value);
    LearnInfo *GetLearnInfo(Widget *widget);
    LearnInfo *GetLearnInfo(Widget*, int modifier);

    void DoTouch(Widget *widget, double value);
    
    void AutoMapFocusedFX();
    void GoLearnFXParams(MediaTrack *track, int fxSlot);
    void SaveLearnedFXParams();
    void SaveTemplatedFXParams();
    void EraseLastTouchedControl();
    
    const string &GetZoneFolder() { return zoneFolder_; }
    map<string, CSIZoneInfo> &GetZoneFilePaths() { return zoneFilePaths_; }
    vector<CSILayoutInfo> &GetFXLayouts() { return fxLayouts_; }
    vector<vector<string>> &GetSurfaceFXLayoutTemplate() { return surfaceFXLayoutTemplate_;}

    ControlSurface *GetSurface() { return surface_; }
    
    void SetHomeZone(Zone *zone) { homeZone_ = zone; }
    void SetFocusedFXParamZone(Zone *zone) { focusedFXParamZone_ = zone; }
    
    int GetTrackSendOffset() { return trackSendOffset_; }
    int GetTrackReceiveOffset() { return trackReceiveOffset_; }
    int GetTrackFXMenuOffset() { return trackFXMenuOffset_; }
    int GetSelectedTrackSendOffset() { return selectedTrackSendOffset_; }
    int GetSelectedTrackReceiveOffset() { return selectedTrackReceiveOffset_; }
    int GetSelectedTrackFXMenuOffset() { return selectedTrackFXMenuOffset_; }
    int GetMasterTrackFXMenuOffset() { return masterTrackFXMenuOffset_; }

    bool GetIsFocusedFXMappingEnabled() { return isFocusedFXMappingEnabled_; }
    bool GetIsFocusedFXParamMappingEnabled() { return isFocusedFXParamMappingEnabled_; }

    void DeclareGoFXSlot(MediaTrack *track, Navigator *navigator, int fxSlot)
    {
        if (listensToLocalFXSlot_ || (! GetIsBroadcaster() && ! GetIsListener())) // No Broadcasters/Listeners relationships defined
            GoFXSlot(track, navigator, fxSlot);
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToGoFXSlot(track, navigator, fxSlot);
    }
    
    void DeclareClearSelectedTrackFX()
    {
        if (listensToLocalFXSlot_ || (! GetIsBroadcaster() && ! GetIsListener())) // No Broadcasters/Listeners relationships defined
            ClearSelectedTrackFX();
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToClearSelectedTrackFX();
    }
    
    void DeclareClearFXSlot(Zone *zone)
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
            ClearFXSlot(zone);
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToClearFXSlot(zone);
    }
                
    void RemoveZone(string zoneName)
    {
        if (zoneFilePaths_.count(zoneName) > 0)
        {
            remove(zoneFilePaths_[zoneName].filePath.c_str());
            zoneFilePaths_.erase(zoneName);
        }
    }
      
    void GetName(MediaTrack *track, int fxIndex, string &name)
    {
        char fxName[BUFSZ];
        DAW::TrackFX_GetFXName(track, fxIndex, fxName, sizeof(fxName));

        if (zoneFilePaths_.count(fxName) > 0)
            name = zoneFilePaths_[fxName].alias;
        else
            GetAlias(fxName,name);
    }
        
    void ClearLearnedFXParams()
    {
        fxLayout_ = nullptr;
        fxLayoutFileLines_.clear();
        fxLayoutFileLinesOriginal_.clear();
        paramList_.clear();
        learnFXName_ = "";
        
        for (auto [widget, modifiers] : learnedFXParams_)
        {
            for (auto [modifier, info] : modifiers)
            {
                info->isLearned = false;
                info->paramNumber = 0;
                info->paramName = "";
                info->params = "";
                info->track = nullptr;
                info->fxSlotNum = 0;
            }
        }
        
        lastTouched_ = nullptr;
    }
        
    void DeclareClearFocusedFXParam()
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
            ClearFocusedFXParam();
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToClearFocusedFXParam();
    }
    
    void DeclareClearFocusedFX()
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
            ClearFocusedFX();
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToClearFocusedFX();
    }
    
    const vector<vector<string>> &GetSurfaceFXLayout()
    {
        return surfaceFXLayout_;
    }
              
    void GoAssociatedZone(const string &zoneName)
    {
        if (noMapZone_ != nullptr)
            noMapZone_->Deactivate();
        
        if (zoneName == "SelectedTrackSend")
            DeclareGoSelectedTrackSend(zoneName);
        else if (zoneName == "SelectedTrackReceive")
            DeclareGoSelectedTrackReceive(zoneName);
        else if (zoneName == "SelectedTrackFX")
            DeclareGoSelectedTrackFX();
        else if (zoneName == "SelectedTrackFXMenu")
            DeclareGoSelectedTrackFXMenu(zoneName);
        else if (zoneName == "LearnFXParams")
            GoLearnFXParams();
        else if (zoneName.substr(0, 6) == "Custom")
            DeclareGoCustom(zoneName);
        else if (homeZone_ != nullptr)
        {
            ClearFXMapping();
            ResetOffsets();
                    
            homeZone_->GoAssociatedZone(zoneName);
        }
    }

    void GoHome()
    {
        int commandId = DAW::NamedCommandLookup("_S&M_WNCLS4"); // Close FX chain windows
        if (commandId)
            DAW::SendCommandMessage(commandId);
        
        commandId = DAW::NamedCommandLookup("_S&M_WNCLS3"); // Close floating FX windows
        if (commandId)
            DAW::SendCommandMessage(commandId);
        
        ClearLearnedFXParams();

        ClearFXMapping();

        if (noMapZone_ != nullptr && noMapZone_->GetIsActive())
            noMapZone_->Deactivate();
        
        if (homeZone_ != nullptr)
        {
            ResetOffsets();
            homeZone_->Activate();
        }
    }
    
    void DeclareGoHome()
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
            GoHome();
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToGoHome();
    }
        
    void OnTrackSelection()
    {
        fxSlotZones_.Empty();
        needGarbageCollect_ = true;
    }

    void OnTrackDeselection()
    {
        if (homeZone_ != nullptr)
        {
            ResetSelectedTrackOffsets();
            
            selectedTrackFXZones_.Empty();
            
            homeZone_->OnTrackDeselection();

            needGarbageCollect_ = true;
        }
    }
    
    void DeclareToggleEnableFocusedFXParamMapping()
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
            ToggleEnableFocusedFXParamMapping();
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToToggleEnableFocusedFXParamMapping();
    }

    void DeclareToggleEnableFocusedFXMapping()
    {
        if (! GetIsBroadcaster() && ! GetIsListener()) // No Broadcasters/Listeners relationships defined
            ToggleEnableFocusedFXMapping();
        else
            for (int i = 0; i < listeners_.GetSize(); ++i)
                listeners_.Get(i)->ListenToToggleEnableFocusedFXMapping();
    }

    bool GetIsHomeZoneOnlyActive()
    {
        if (homeZone_ !=  nullptr)
            return homeZone_->GetIsMainZoneOnlyActive();
        else
            return false;
    }
    
    bool GetIsAssociatedZoneActive(const string &zoneName)
    {
        if (homeZone_ !=  nullptr)
            return homeZone_->GetIsAssociatedZoneActive(zoneName);
        else
            return false;
    }
    
    void ClearFXMapping()
    {
        focusedFXZones_.Empty();
        selectedTrackFXZones_.Empty();
        fxSlotZones_.Empty();

        needGarbageCollect_ = true;
    }
        
    void AdjustBank(const string &zoneName, int amount)
    {
        if(zoneName == "TrackSend")
            AdjustBank(trackSendOffset_, amount);
        else if(zoneName == "TrackReceive")
            AdjustBank(trackReceiveOffset_, amount);
        else if(zoneName == "TrackFXMenu")
            AdjustBank(trackFXMenuOffset_, amount);
        else if(zoneName == "SelectedTrackSend")
            AdjustBank(selectedTrackSendOffset_, amount);
        else if(zoneName == "SelectedTrackReceive")
            AdjustBank(selectedTrackReceiveOffset_, amount);
        else if(zoneName == "SelectedTrackFXMenu")
            AdjustBank(selectedTrackFXMenuOffset_, amount);
        else if(zoneName == "MasterTrackFXMenu")
            AdjustBank(masterTrackFXMenuOffset_, amount);
    }
             
    void AddWidget(Widget *widget)
    {
        usedWidgets_[widget] = false;
    }
    
    void AddZoneFilePath(const string &name, const struct CSIZoneInfo &info)
    {
        if (name != "")
            zoneFilePaths_[name] = info;
    }
        
    void AddZoneFilePath(const string &fxZoneFolder, const string &name, const struct CSIZoneInfo &info)
    {
        if (fxZoneFolder == fxZoneFolder_)
            AddZoneFilePath(name, info);
    }
               
    void RequestUpdate()
    {
        CheckFocusedFXState();
            
        for (auto &[key, value] : usedWidgets_)
            value = false;

        if (noMapZone_ != nullptr)
            noMapZone_->RequestUpdate(usedWidgets_);
        
        if (homeZone_ != nullptr && homeZone_->GetIsAssociatedZoneActive("LearnFXParams"))
        {
            homeZone_->RequestUpdate(usedWidgets_);
            homeZone_->GetLearnFXParamsZone()->RequestLearnFXUpdate(usedWidgets_);
        }

        if (focusedFXParamZone_ != nullptr && isFocusedFXParamMappingEnabled_)
            focusedFXParamZone_->RequestUpdate(usedWidgets_);

        for (int i = 0; i < focusedFXZones_.GetSize(); ++i)
            focusedFXZones_.Get(i)->RequestUpdate(usedWidgets_);
        
        for (int i = 0; i < selectedTrackFXZones_.GetSize(); ++i)
            selectedTrackFXZones_.Get(i)->RequestUpdate(usedWidgets_);
        
        for (int i = 0; i < fxSlotZones_.GetSize(); ++i)
            fxSlotZones_.Get(i)->RequestUpdate(usedWidgets_);
        
        if (homeZone_ != nullptr)
            homeZone_->RequestUpdate(usedWidgets_);
        
        // default is to zero unused Widgets -- for an opposite sense device, you can override this by supplying an inverted NoAction context in the Home Zone
        map<string, string> properties;
        
        for (auto &[widget, value] : usedWidgets_)
        {
            if (value == false)
            {
                rgba_color color;
                widget->UpdateValue(properties, 0.0);
                widget->UpdateValue(properties, "");
                widget->UpdateColorValue(color);
            }
        }
        
        GarbageCollectZones();
    }

    void DoAction(Widget *widget, double value)
    {
        if (WDL_NOT_NORMALLY(!widget)) return;
        widget->LogInput(value);
        
        bool isUsed = false;
        
        if (noMapZone_ != nullptr && noMapZone_->GetIsActive())
            noMapZone_->DoAction(widget, isUsed, value);
        
        if (focusedFXParamZone_ != nullptr && isFocusedFXParamMappingEnabled_)
            focusedFXParamZone_->DoAction(widget, isUsed, value);

        for (int i = 0; i < focusedFXZones_.GetSize(); ++i)
            focusedFXZones_.Get(i)->DoAction(widget, isUsed, value);
        
        if (isUsed)
            return;
        
        for (int i = 0; i < selectedTrackFXZones_.GetSize(); ++i)
            selectedTrackFXZones_.Get(i)->DoAction(widget, isUsed, value);
        
        if (isUsed)
            return;
   
        for (int i = 0; i < fxSlotZones_.GetSize(); ++i)
            fxSlotZones_.Get(i)->DoAction(widget, isUsed, value);
        
        if (isUsed)
            return;

        if (homeZone_ != nullptr)
            homeZone_->DoAction(widget, isUsed, value);
    }
    
    void DoRelativeAction(Widget *widget, double delta)
    {
        if (WDL_NOT_NORMALLY(!widget)) return;
        widget->LogInput(delta);
        
        bool isUsed = false;
        
        if (focusedFXParamZone_ != nullptr && isFocusedFXParamMappingEnabled_)
            focusedFXParamZone_->DoRelativeAction(widget, isUsed, delta);

        for (int i = 0; i < focusedFXZones_.GetSize(); ++i)
            focusedFXZones_.Get(i)->DoRelativeAction(widget, isUsed, delta);
        
        if (isUsed)
            return;
        
        for (int i = 0; i < selectedTrackFXZones_.GetSize(); ++i)
            selectedTrackFXZones_.Get(i)->DoRelativeAction(widget, isUsed, delta);
        
        if (isUsed)
            return;

        for (int i = 0; i < fxSlotZones_.GetSize(); ++i)
            fxSlotZones_.Get(i)->DoRelativeAction(widget, isUsed, delta);
        
        if (isUsed)
            return;

        if (homeZone_ != nullptr)
            homeZone_->DoRelativeAction(widget, isUsed, delta);
    }
    
    void DoRelativeAction(Widget *widget, int accelerationIndex, double delta)
    {
        if (WDL_NOT_NORMALLY(!widget)) return;
        widget->LogInput(delta);
        
        bool isUsed = false;
           
        if (focusedFXParamZone_ != nullptr && isFocusedFXParamMappingEnabled_)
            focusedFXParamZone_->DoRelativeAction(widget, isUsed, accelerationIndex, delta);
        
        for (int i = 0; i < focusedFXZones_.GetSize(); ++i)
            focusedFXZones_.Get(i)->DoRelativeAction(widget, isUsed, accelerationIndex, delta);
        
        if (isUsed)
            return;
        
        for (int i = 0; i < selectedTrackFXZones_.GetSize(); ++i)
            selectedTrackFXZones_.Get(i)->DoRelativeAction(widget, isUsed, accelerationIndex, delta);
        
        if (isUsed)
            return;

        for (int i = 0; i < fxSlotZones_.GetSize(); ++i)
            fxSlotZones_.Get(i)->DoRelativeAction(widget, isUsed, accelerationIndex, delta);
        
        if (isUsed)
            return;

        if (homeZone_ != nullptr)
            homeZone_->DoRelativeAction(widget, isUsed, accelerationIndex, delta);
    }
    
    int GetNumGroups()
    {
        int numGroups = 0;
        
        for (int i = 0; i < (int)surfaceFXLayoutTemplate_.size(); ++i)
        {
            if (surfaceFXLayoutTemplate_[i].size() > 0 && surfaceFXLayoutTemplate_[i][0] == "WidgetTypes")
            {
                numGroups = (int)surfaceFXLayoutTemplate_[i].size() - 1;
                break;
            }
        }
        
        return  numGroups;
    }
    
    vector<FXParamLayoutTemplate> GetFXLayoutTemplates()
    {
        vector<FXParamLayoutTemplate> layoutTemplates;
        
        string widgetAction = "";
        string aliasDisplayAction = "";
        string valueDisplayAction = "";

        for (int i = 0; i < (int)surfaceFXLayoutTemplate_.size(); ++i)
        {
            if (surfaceFXLayoutTemplate_[i].size() > 1)
            {
                if (surfaceFXLayoutTemplate_[i][0] == "WidgetAction")
                    widgetAction = surfaceFXLayoutTemplate_[i][1];
                else if (surfaceFXLayoutTemplate_[i][0] == "AliasDisplayAction")
                    aliasDisplayAction = surfaceFXLayoutTemplate_[i][1];
                else if (surfaceFXLayoutTemplate_[i][0] == "ValueDisplayAction")
                    valueDisplayAction = surfaceFXLayoutTemplate_[i][1];
            }
        }
        
        for (int i = 0; i < (int)GetFXLayouts().size(); ++i)
        {
            for (int i = 0; i < GetFXLayouts()[i].channelCount; i++)
            {
                string modifiers = "";
                if (GetFXLayouts()[i].modifiers != "")
                    modifiers = GetFXLayouts()[i].modifiers + "+";
                
                FXParamLayoutTemplate layoutTemplate;
                
                layoutTemplate.modifiers = modifiers;
                layoutTemplate.suffix = GetFXLayouts()[i].suffix + to_string(i + 1);
                
                layoutTemplate.widgetAction = widgetAction;
                layoutTemplate.aliasDisplayAction = aliasDisplayAction;
                layoutTemplate.valueDisplayAction = valueDisplayAction;
                
                layoutTemplates.push_back(layoutTemplate);
            }
        }

        return layoutTemplates;
    }
    
    void UnpackZone(AutoZoneDefinition &zoneDef, vector<FXParamLayoutTemplate> &layoutTemplates)
    {
        zoneDef.paramDefs.clear();
        zoneDef.prologue.clear();
        zoneDef.epilogue.clear();
        zoneDef.rawParams.clear();
        zoneDef.rawParamsDictionary.clear();

        zoneDef.fxName = "";
        zoneDef.fxAlias = "";

        bool inZone = false;
        bool inAutoZone = false;
        bool pastAutoZone = false;
        
        ifstream autoFXFile(zoneDef.fullPath);
        
        int listSlotIndex = 0;
        
        FXParamDefinitions definitions;
        zoneDef.paramDefs.push_back(definitions);
        
        for (string line; getline(autoFXFile, line) ; )
        {
            line = regex_replace(line, regex(s_CRLFChars), "");

            if (inAutoZone && ! pastAutoZone)
            {
                // Trim leading and trailing spaces
                line = regex_replace(line, regex("^\\s+|\\s+$"), "", regex_constants::format_default);
                
                if (line == "" || (line.size() > 0 && line[0] == '/')) // ignore blank lines and comment lines
                    continue;
            }

            vector<string> tokens;
            GetTokens(tokens, line);

            if (line.substr(0, 5) == "Zone ")
            {
                inZone = true;
                
                if (tokens.size() > 1)
                    zoneDef.fxName = tokens[1];
                if (tokens.size() > 2)
                    zoneDef.fxAlias = tokens[2];
                
                continue;
            }
            else if (line == s_BeginAutoSection)
            {
                inAutoZone = true;
                continue;
            }
            else if (inZone && ! inAutoZone)
            {
                zoneDef.prologue.push_back(line);
                continue;
            }
            else if (line == s_EndAutoSection)
            {
                pastAutoZone = true;
                continue;
            }
            else if (line == "ZoneEnd")
            {
                inZone = false;
                continue;
            }
            else if (inZone && pastAutoZone)
            {
                zoneDef.epilogue.push_back(line);
                continue;
            }
            else if (! inZone && pastAutoZone)
            {
                if (line != "")
                    zoneDef.rawParams.push_back(line);
                continue;
            }
            else
            {
                tokens.clear();
                GetTokens(tokens, line);
                
                if (tokens[0].find(layoutTemplates[listSlotIndex].suffix) == string::npos)
                {
                    listSlotIndex++;
                    FXParamDefinitions definitions;
                    zoneDef.paramDefs.push_back(definitions);
                }
                
                FXParamDefinition def;
                
                GetWidgetNameAndModifiers(tokens[0], listSlotIndex, def.cell,  def.paramWidget, def.paramWidgetFullName, def.modifiers, def.modifier, layoutTemplates);
                
                if (tokens.size() > 2)
                    def.paramNumber = tokens[2];
                
                int propertiesOffset = 3;
                
                if (tokens.size() > 4 && tokens[3] == "[")
                {
                    vector<string> params;

                    for (int i = 3; i < tokens.size() && tokens[i] != "]"; i++)
                        params.push_back(tokens[i]);
                    
                    params.push_back("]");
                 
                    propertiesOffset += (int)params.size();
                    
                    GetSteppedValues(params, def.delta, def.deltas, def.rangeMinimum, def.rangeMaximum, def.steps, def.ticks);
                }
                                       
                if (tokens.size() > propertiesOffset)
                    GetProperties(propertiesOffset, (int)tokens.size(), tokens, def.paramWidgetProperties);
                
                if (getline(autoFXFile, line))
                {
                    vector<string> tokens;
                    GetTokens(tokens, line);

                    if (tokens.size() > 2)
                    {
                        vector<string> modifers;
                        
                        GetWidgetNameAndModifiers(tokens[0], listSlotIndex, def.cell, def.paramNameDisplayWidget, def.paramNameDisplayWidgetFullName, def.modifiers, def.modifier, layoutTemplates);
                        
                        def.paramName = tokens[2];
                        
                        if (tokens.size() > 3)
                            GetProperties(3, (int)tokens.size(), tokens, def.paramNameDisplayWidgetProperties);
                    }
                }
                else
                    continue;
                
                if (getline(autoFXFile, line))
                {
                    vector<string> tokens;
                    GetTokens(tokens, line);

                    if (tokens.size() > 2)
                    {
                        vector<string> modifers;
                        
                        GetWidgetNameAndModifiers(tokens[0], listSlotIndex, def.cell, def.paramValueDisplayWidget, def.paramValueDisplayWidgetFullName, def.modifiers, def.modifier, layoutTemplates);
                        
                        if (tokens.size() > 3)
                            GetProperties(3, (int)tokens.size(), tokens, def.paramValueDisplayWidgetProperties);
                    }
                }
                else
                    continue;
               
                zoneDef.paramDefs.back().definitions.push_back(def);
            }
        }
    }

    void SaveAutoZone(const AutoZoneDefinition &zoneDef, const vector<FXParamLayoutTemplate> &layoutTemplates)
    {
        ofstream fxFile(zoneDef.fullPath);
        
        if (fxFile.is_open())
        {
            fxFile << "Zone \"" + zoneDef.fxName + "\" \"" + zoneDef.fxAlias + "\"\n";
            
            for (int i = 0; i < (int)zoneDef.prologue.size(); ++i)
                fxFile << zoneDef.prologue[i] + "\n";
            
            fxFile << s_BeginAutoSection + "\n\n";
            
            for (int i = 0; i < zoneDef.paramDefs.size(); i++)
            {
                bool cellHasDisplayWidgetsDefined = false;
                
                for (int j = 0; j < zoneDef.paramDefs[i].definitions.size(); j++)
                {
                    fxFile << "\t" + layoutTemplates[i].modifiers + zoneDef.paramDefs[i].definitions[j].paramWidget + layoutTemplates[i].suffix + "\t";
                    
                    if (zoneDef.paramDefs[i].definitions[j].paramNumber == "")
                    {
                        fxFile << "NoAction\n";
                    }
                    else
                    {
                        fxFile << layoutTemplates[i].widgetAction + " " + zoneDef.paramDefs[i].definitions[j].paramNumber + " ";
                        
                        if (zoneDef.paramDefs[i].definitions[j].delta != "" ||
                           (zoneDef.paramDefs[i].definitions[j].rangeMinimum != ""  && zoneDef.paramDefs[i].definitions[j].rangeMaximum != "") ||
                           zoneDef.paramDefs[i].definitions[j].deltas.size() > 0 ||
                           zoneDef.paramDefs[i].definitions[j].ticks.size() > 0 ||
                           zoneDef.paramDefs[i].definitions[j].steps.size() > 0)
                        {
                            fxFile << "[ ";
                            
                            if (zoneDef.paramDefs[i].definitions[j].rangeMinimum != ""  && zoneDef.paramDefs[i].definitions[j].rangeMaximum != "")
                                fxFile << " " + zoneDef.paramDefs[i].definitions[j].rangeMinimum + ">" + zoneDef.paramDefs[i].definitions[j].rangeMaximum + " ";
                            
                            if (zoneDef.paramDefs[i].definitions[j].delta != "")
                                fxFile << " (" + zoneDef.paramDefs[i].definitions[j].delta + ") ";
                            
                            if (zoneDef.paramDefs[i].definitions[j].deltas.size() > 0)
                            {
                                string deltaStr = " (";
                                
                                for (int k = 0; k < (int)zoneDef.paramDefs[i].definitions[j].deltas.size(); ++k)
                                    deltaStr += zoneDef.paramDefs[i].definitions[j].deltas[k] + ",";
                                
                                deltaStr = deltaStr.substr(0, deltaStr.length() - 1);
                                
                                deltaStr += ") ";
                                
                                fxFile << deltaStr;
                            }
                            
                            if (zoneDef.paramDefs[i].definitions[j].ticks.size() > 0)
                            {
                                string tickStr = " (";
                                
                                for (int k = 0; k < (int)zoneDef.paramDefs[i].definitions[j].ticks.size(); ++k)
                                    tickStr += zoneDef.paramDefs[i].definitions[j].ticks[k] + ",";
                                
                                tickStr = tickStr.substr(0, tickStr.length() - 1);
                                
                                tickStr += ") ";
                                
                                fxFile << tickStr;
                            }
                            
                            for (int k = 0; k < (int)zoneDef.paramDefs[i].definitions[j].steps.size(); ++k)
                                fxFile << zoneDef.paramDefs[i].definitions[j].steps[k] + " " ;
                            
                            fxFile << "]";
                        }
                        
                        for (auto [ key, value ] : zoneDef.paramDefs[i].definitions[j].paramWidgetProperties)
                            fxFile << " " + key + "=" + value ;
                        
                        fxFile << "\n";
                    }
                    
                    if (zoneDef.paramDefs[i].definitions[j].paramNumber == "" || zoneDef.paramDefs[i].definitions[j].paramNameDisplayWidget == "")
                    {
                        if (! cellHasDisplayWidgetsDefined && j == zoneDef.paramDefs[i].definitions.size() - 1 && surfaceFXLayout_.size() > 1 && surfaceFXLayout_[1].size() > 0)
                            fxFile << "\t" + layoutTemplates[i].modifiers + surfaceFXLayout_[1][0] + layoutTemplates[i].suffix + "\tNoAction\n";
                        else
                            fxFile << "\tNullDisplay\tNoAction\n";
                    }
                    else
                    {
                        cellHasDisplayWidgetsDefined = true;
                        
                        fxFile << "\t" + layoutTemplates[i].modifiers + zoneDef.paramDefs[i].definitions[j].paramNameDisplayWidget + layoutTemplates[i].suffix + "\t";
                        
                        fxFile << layoutTemplates[i].aliasDisplayAction + " \"" + zoneDef.paramDefs[i].definitions[j].paramName + "\" ";
                        
                        for (auto [ key, value ] : zoneDef.paramDefs[i].definitions[j].paramNameDisplayWidgetProperties)
                            fxFile << " " + key + "=" + value;
                        
                        fxFile << "\n";
                    }
                    
                    if (zoneDef.paramDefs[i].definitions[j].paramNumber == "" || zoneDef.paramDefs[i].definitions[j].paramValueDisplayWidget == "")
                    {
                        if (! cellHasDisplayWidgetsDefined && j == zoneDef.paramDefs[i].definitions.size() - 1 && surfaceFXLayout_.size() > 2 && surfaceFXLayout_[2].size() > 0)
                            fxFile << "\t" + layoutTemplates[i].modifiers + surfaceFXLayout_[2][0] + layoutTemplates[i].suffix + "\tNoAction\n";
                        else
                            fxFile << "\tNullDisplay\tNoAction\n";
                    }
                    else
                    {
                        cellHasDisplayWidgetsDefined = true;

                        fxFile << "\t" + layoutTemplates[i].modifiers + zoneDef.paramDefs[i].definitions[j].paramValueDisplayWidget + layoutTemplates[i].suffix + "\t";
                        
                        fxFile << layoutTemplates[i].valueDisplayAction + " " + zoneDef.paramDefs[i].definitions[j].paramNumber;
                        
                        for (auto [ key, value ] : zoneDef.paramDefs[i].definitions[j].paramValueDisplayWidgetProperties)
                            fxFile << " " + key + "=" + value;
                        
                        fxFile << "\n";
                    }
                    
                    fxFile << "\n";
                }
                
                fxFile << "\n";
            }
            
            fxFile <<  s_EndAutoSection + "\n";
            
            for (int i = 0; i < (int)zoneDef.epilogue.size(); ++i)
                fxFile << zoneDef.epilogue[i] + "\n";
            
            fxFile << "ZoneEnd\n";
            
            for (int i = 0; i < (int)zoneDef.rawParams.size(); ++i)
                fxFile << zoneDef.rawParams[i] + "\n";
            
            fxFile.close();
        }
    }

    WDL_PtrList<Zone> allZonesNeedFree_;
    void GarbageCollectZones();
    void LoadZoneFile(const string &filePath, const WDL_PtrList<Navigator> &navigators, WDL_PtrList<Zone> &zones, Zone *enclosingZone);
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CSIMessageGenerator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
protected:
    Widget  *const widget_;
    
public:
    CSIMessageGenerator(Widget *widget) : widget_(widget) {}
    virtual ~CSIMessageGenerator() {}
    
    virtual void ProcessMessage(double value)
    {
        widget_->GetZoneManager()->DoAction(widget_, value);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class AnyPress_CSIMessageGenerator : public CSIMessageGenerator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    AnyPress_CSIMessageGenerator(Widget *widget) : CSIMessageGenerator(widget) {}
    virtual ~AnyPress_CSIMessageGenerator() {}
    
    virtual void ProcessMessage(double value) override
    {
        widget_->GetZoneManager()->DoAction(widget_, 1.0);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MotorizedFaderWithoutTouch_CSIMessageGenerator : public CSIMessageGenerator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    MotorizedFaderWithoutTouch_CSIMessageGenerator(Widget *widget) : CSIMessageGenerator(widget) {}
    virtual ~MotorizedFaderWithoutTouch_CSIMessageGenerator() {}
    
    virtual void ProcessMessage(double value) override
    {
        widget_->SetIncomingMessageTime(DAW::GetCurrentNumberOfMilliseconds());
        widget_->GetZoneManager()->DoAction(widget_, value);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Touch_CSIMessageGenerator : public CSIMessageGenerator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    Touch_CSIMessageGenerator(Widget *widget) : CSIMessageGenerator(widget) {}
    virtual ~Touch_CSIMessageGenerator() {}
    
    virtual void ProcessMessage(double value) override
    {
        widget_->GetZoneManager()->DoTouch(widget_, value);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class ModifierManager
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    Page *page_;
    ControlSurface *surface_;
    
    int latchTime_;
    
    enum Modifiers
    {
        ErrorModifier = -1,
        Shift = 0,
        Option,
        Control,
        Alt,
        Flip,
        Global,
        Marker,
        Nudge,
        Zoom,
        Scrub,
        MaxModifiers
    };
    
    static int maskFromModifier(Modifiers m)
    {
      if (WDL_NOT_NORMALLY(m == ErrorModifier)) return 0;
      return 4 << (int) m;
    }
    static Modifiers modifierFromString(const char *s)
    {
         if (!strcmp(s,"Shift")) return Shift;
         if (!strcmp(s,"Option")) return Option;
         if (!strcmp(s,"Control")) return Control;
         if (!strcmp(s,"Alt")) return Alt;
         if (!strcmp(s,"Flip")) return Flip;
         if (!strcmp(s,"Global")) return Global;
         if (!strcmp(s,"Marker")) return Marker;
         if (!strcmp(s,"Nudge")) return Nudge;
         if (!strcmp(s,"Zoom")) return Zoom;
         if (!strcmp(s,"Scrub")) return Scrub;
         return ErrorModifier;
    }

    static const char *stringFromModifier(Modifiers mod)
    {
      switch (mod)
      {
        case Shift: return "Shift";
        case Option: return "Option";
        case Control: return "Control";
        case Alt: return "Alt";
        case Flip: return "Flip";
        case Global: return "Global";
        case Marker: return "Marker";
        case Nudge: return "Nudge";
        case Zoom: return "Zoom";
        case Scrub: return "Scrub";
        default:
          WDL_ASSERT(false);
        return "";
      }
    }

    struct ModifierState
    {
        bool isEngaged;
        double pressedTime;
    };
    ModifierState modifiers_[MaxModifiers];
    WDL_TypedBuf<int> modifierCombinations_;
    static int intcmp_rev(const void *a, const void *b) { return *(const int *)a > *(const int *)b ? -1 : *(const int *)a < *(const int *)b ? 1 : 0; }
    
    void GetCombinations(const Modifiers *indices, int num_indices, WDL_TypedBuf<int> &combinations)
    {
        for (int mask = 0; mask < (1 << num_indices); mask++)
        {
            int combination = 0;
            
            for (int position = 0; position < num_indices; position++)
                if (mask & (1 << position))
                    combination |= maskFromModifier(indices[position]);
            
            if (combination != 0)
                combinations.Add(combination);
        }
    }

    void SetLatchModifier(bool value, Modifiers modifier, int latchTime);

public:
    ModifierManager()
    {
        // private:
        page_ = nullptr;
        surface_ = nullptr;
        latchTime_ = 100;

        int *p = modifierCombinations_.ResizeOK(1);
        if (WDL_NORMALLY(p)) p[0]=0;

        memset(modifiers_,0,sizeof(modifiers_));
    }
    
    ModifierManager(Page *page) : ModifierManager()
    {
        page_ = page;
    }
    
    ModifierManager(ControlSurface *surface) : ModifierManager()
    {
        surface_ = surface;
    }
    
    void RecalculateModifiers();
    const WDL_TypedBuf<int> &GetModifiers() { return modifierCombinations_; }
    
    bool GetShift() { return modifiers_[Shift].isEngaged; }
    bool GetOption() { return modifiers_[Option].isEngaged; }
    bool GetControl() { return modifiers_[Control].isEngaged; }
    bool GetAlt() { return modifiers_[Alt].isEngaged; }
    bool GetFlip() { return modifiers_[Flip].isEngaged; }
    bool GetGlobal() { return modifiers_[Global].isEngaged; }
    bool GetMarker() { return modifiers_[Marker].isEngaged; }
    bool GetNudge() { return modifiers_[Nudge].isEngaged; }
    bool GetZoom() { return modifiers_[Zoom].isEngaged; }
    bool GetScrub() { return modifiers_[Scrub].isEngaged; }

    void ClearModifier(const string &modifierString)
    {
        Modifiers m = modifierFromString(modifierString.c_str());
        if (m != ErrorModifier)
        {
            modifiers_[m].isEngaged = false;
            RecalculateModifiers();
        }
    }

    static string GetModifierString(int modifierValue)
    {
        string modifierString = "";
        for (int x = 0; x < MaxModifiers; x++)
            if (modifierValue & maskFromModifier((Modifiers)x))
            {
                modifierString += stringFromModifier((Modifiers)x);
                modifierString += "+";
            }

        return modifierString;
    }

    int GetModifierValue(const vector<string> &tokens)
    {
        int modifierValue = 0;
        for (int i = 0; i < tokens.size() - 1; i++)
        {
            Modifiers m = modifierFromString(tokens[i].c_str());
            if (m != ErrorModifier)
                modifierValue |= maskFromModifier(m);
        }
        
        return modifierValue;
    }

    void SetShift(bool value, int latchTime)
    {
        SetLatchModifier(value, Shift, latchTime);
    }

    void SetOption(bool value, int latchTime)
    {
        SetLatchModifier(value, Option, latchTime);
    }
    
    void SetControl(bool value, int latchTime)
    {
        SetLatchModifier(value, Control, latchTime);
    }
    
    void SetAlt(bool value, int latchTime)
    {
        SetLatchModifier(value, Alt, latchTime);
    }
  
    void SetFlip(bool value, int latchTime)
    {
        SetLatchModifier(value, Flip, latchTime);
    }
  
    void SetGlobal(bool value, int latchTime)
    {
        SetLatchModifier(value, Global, latchTime);
    }
    
    void SetMarker(bool value, int latchTime)
    {
        modifiers_[Nudge].isEngaged = false;
        modifiers_[Zoom].isEngaged = false;
        modifiers_[Scrub].isEngaged = false;

        SetLatchModifier(value, Marker, latchTime);
    }
    
    void SetNudge(bool value, int latchTime)
    {
        modifiers_[Marker].isEngaged = false;
        modifiers_[Zoom].isEngaged = false;
        modifiers_[Scrub].isEngaged = false;

        SetLatchModifier(value, Nudge, latchTime);
    }
  
    void SetZoom(bool value, int latchTime)
    {
        modifiers_[Marker].isEngaged = false;
        modifiers_[Nudge].isEngaged = false;
        modifiers_[Scrub].isEngaged = false;

        SetLatchModifier(value, Zoom, latchTime);
    }
  
    void SetScrub(bool value, int latchTime)
    {
        modifiers_[Marker].isEngaged = false;
        modifiers_[Nudge].isEngaged = false;
        modifiers_[Zoom].isEngaged = false;

        SetLatchModifier(value, Scrub, latchTime);
    }
    
    void ClearModifiers()
    {
        for (int i = 0; i < MaxModifiers; ++i)
            modifiers_[i].isEngaged = false;
        
        RecalculateModifiers();
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ChannelTouch
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
    int channelNum;
    bool isTouched;
    
    ChannelTouch()
    {
        channelNum = 0;
        isTouched = false;
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct ChannelToggle
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
    int channelNum;
    bool isToggled;
    
    ChannelToggle()
    {
        channelNum = 0;
        isToggled = false;
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class ControlSurface
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{    
private:
    int *scrubModePtr_;
    int configScrubMode_;

    bool isRewinding_;
    bool isFastForwarding_;
    
    bool isTextLengthRestricted_;
    int restrictedTextLength_;
    
    bool usesLocalModifiers_;
    bool listensToModifiers_;
    
    int latchTime_;
        
    WDL_PtrList<FeedbackProcessor> trackColorFeedbackProcessors_; // does not own pointers
    vector<rgba_color> fixedTrackColors_;
    
    WDL_TypedBuf<ChannelTouch> channelTouches_;
    WDL_TypedBuf<ChannelToggle> channelToggles_;

protected:
    Page *const page_;
    string const name_;
    ZoneManager *zoneManager_;
    ModifierManager *modifierManager_;
    
    int const numChannels_ = 0;
    int const channelOffset_ = 0;
    
    WDL_PtrList<Widget> widgets_; // owns list
    WDL_StringKeyedArray<Widget*> widgetsByName_;
    
    map<string, CSIMessageGenerator*> CSIMessageGeneratorsByMessage_;
    
    bool speedX5_;

    ControlSurface(Page *page, const string &name, int numChannels, int channelOffset) : page_(page), name_(name), numChannels_(numChannels), channelOffset_(channelOffset)
    {
        //private:
        scrubModePtr_ = nullptr;
        configScrubMode_ = 0;

        isRewinding_ = false;
        isFastForwarding_ = false;
        
        isTextLengthRestricted_ = false;
        restrictedTextLength_ = 6;
        
        usesLocalModifiers_ = false;
        listensToModifiers_ = false;
        
        latchTime_ = 100;
        
        // protected
        zoneManager_ = NULL;
        modifierManager_ = new ModifierManager(this);
        speedX5_ = false;
        
        int size = 0;
        scrubModePtr_ = (int*)get_config_var("scrubmode", &size);
        
        for (int i = 1 ; i <= numChannels; i++)
        {
            ChannelTouch channelTouch;
            channelTouch.channelNum = i;
            channelTouches_.Add(channelTouch);
            
            ChannelToggle channelToggle;
            channelToggle.channelNum = i;
            channelToggles_.Add(channelToggle);
        }
    }
    
    void StopRewinding()
    {
        isRewinding_ = false;
        *scrubModePtr_ = configScrubMode_;
    
        speedX5_ = false;
    }
    
    void StopFastForwarding()
    {
        isFastForwarding_ = false;
        *scrubModePtr_ = configScrubMode_;
    
        speedX5_ = false;
    }
        
    void CancelRewindAndFastForward()
    {
        if (isRewinding_)
            StopRewinding();
        else if (isFastForwarding_)
            StopFastForwarding();
    }
    
    virtual void InitHardwiredWidgets(ControlSurface *surface)
    {
        // Add the "hardwired" widgets
        AddWidget(new Widget(surface, "OnTrackSelection"));
        AddWidget(new Widget(surface, "OnPageEnter"));
        AddWidget(new Widget(surface, "OnPageLeave"));
        AddWidget(new Widget(surface, "OnInitialization"));
        AddWidget(new Widget(surface, "OnPlayStart"));
        AddWidget(new Widget(surface, "OnPlayStop"));
        AddWidget(new Widget(surface, "OnRecordStart"));
        AddWidget(new Widget(surface, "OnRecordStop"));
        AddWidget(new Widget(surface, "OnZoneActivation"));
        AddWidget(new Widget(surface, "OnZoneDeactivation"));
    }
    
public:
    virtual ~ControlSurface()
    {
        widgets_.Empty(true);
        delete zoneManager_;
        delete modifierManager_;
        
        for ( auto [key, generator] : CSIMessageGeneratorsByMessage_)
            if (generator != nullptr)
                delete generator;
    }
    
    void Stop();
    void Play();
    void Record();
        
    virtual void RequestUpdate();
    void ForceClearTrack(int trackNum);
    void ForceUpdateTrackColors();
    void OnTrackSelection(MediaTrack *track);
    virtual void SetHasMCUMeters(int displayType) {}
    virtual void SendOSCMessage(const string &zoneName) {}
    virtual void SendOSCMessage(const string &zoneName, int value) {}
    virtual void SendOSCMessage(const string &zoneName, double value) {}
    virtual void SendOSCMessage(const string &zoneName, const string &value) {}

    virtual void HandleExternalInput() {}
    virtual void UpdateTimeDisplay() {}
    
    virtual void SendMidiSysExMessage(MIDI_event_ex_t *midiMessage) {}
    virtual void SendMidiMessage(int first, int second, int third) {}
    
    ModifierManager *GetModifierManager() { return modifierManager_; }
    ZoneManager *GetZoneManager() { return zoneManager_; }
    Page *GetPage() { return page_; }
    string GetName() { return name_; }
    
    int GetNumChannels() { return numChannels_; }
    int GetChannelOffset() { return channelOffset_; }
    rgba_color GetTrackColorForChannel(int channel);

    bool GetIsRewinding() { return isRewinding_; }
    bool GetIsFastForwarding() { return isFastForwarding_; }

    bool GetUsesLocalModifiers() { return usesLocalModifiers_; }
    void ToggleUseLocalModifiers() { usesLocalModifiers_ = ! usesLocalModifiers_; }
    bool GetListensToModifiers() { return listensToModifiers_; }
    void SetListensToModifiers() { listensToModifiers_ = true; }

    void SetLatchTime(int latchTime) { latchTime_ = latchTime; }
    int GetLatchTime() { return latchTime_; }

    void TouchChannel(int channelNum, bool isTouched)
    {
        for(int i = 0; i < channelTouches_.GetSize(); ++i)
            if(channelTouches_.Get()[i].channelNum == channelNum)
            {
                channelTouches_.Get()[i].isTouched = isTouched;
                break;
            }
    }
    
    bool GetIsChannelTouched(int channelNum)
    {
        for(int i = 0; i < channelTouches_.GetSize(); ++i)
            if(channelTouches_.Get()[i].channelNum == channelNum)
                return channelTouches_.Get()[i].isTouched;

        return false;
    }
       
    void ToggleChannel(int channelNum)
    {
        for(int i = 0; i < channelToggles_.GetSize(); ++i)
            if(channelToggles_.Get()[i].channelNum == channelNum)
            {
                channelToggles_.Get()[i].isToggled = ! channelToggles_.Get()[i].isToggled;
                break;
            }
    }
    
    bool GetIsChannelToggled(int channelNum)
    {
        for(int i = 0; i < channelToggles_.GetSize(); ++i)
            if(channelToggles_.Get()[i].channelNum == channelNum)
                return channelToggles_.Get()[i].isToggled;

        return false;
    }

    void ToggleRestrictTextLength(int length)
    {
        isTextLengthRestricted_ = ! isTextLengthRestricted_;
        restrictedTextLength_ = length;
    }
    
    string GetRestrictedLengthText(const string &text)
    {
        string restrictedText = text;

        if (isTextLengthRestricted_ && text.length() > restrictedTextLength_)
        {
            string firstLetter = restrictedText.substr(0, 1);
            
            restrictedText = restrictedText.substr(1, restrictedText.length() - 1);
            
            restrictedText = regex_replace(restrictedText, regex("[\\s]"), "");

            if (restrictedText.length() <= restrictedTextLength_ - 1)
                return firstLetter + restrictedText;
            
            restrictedText = regex_replace(restrictedText, regex("[`~!@#$%^&*:()_|=?;:'\",]"), "");

            if (restrictedText.length() <= restrictedTextLength_ - 1)
                return firstLetter + restrictedText;
            
            restrictedText = regex_replace(restrictedText, regex("[aeiou]"), "");

            restrictedText = firstLetter + restrictedText;
            
            if (restrictedText.length() > restrictedTextLength_)
                restrictedText = restrictedText.substr(0, restrictedTextLength_);
        }

        return restrictedText;
    }
           
    void AddTrackColorFeedbackProcessor(FeedbackProcessor *feedbackProcessor) // does not own this pointer
    {
        if (WDL_NOT_NORMALLY(!feedbackProcessor)) { return; }
        trackColorFeedbackProcessors_.Add(feedbackProcessor);
    }
    
    void SetFixedTrackColors(const vector<rgba_color> &colors)
    {
        fixedTrackColors_.clear();
        
        for (int i = 0; i < (int)colors.size(); ++i)
            fixedTrackColors_.push_back(colors[i]);
    }
        
    void ForceClear()
    {
        for (int i = 0; i < widgets_.GetSize(); ++i)
            widgets_.Get(i)->ForceClear();
    }
           
    void TrackFXListChanged(MediaTrack *track)
    {
        OnTrackSelection(track);
    }

    void DoWidgetAction(const char *name, double v=1.0)
    {
        Widget *w = widgetsByName_.Get(name);
        if (w) zoneManager_->DoAction(w, 1.0);
    }
    
    void HandleStop()
    {
        DoWidgetAction("OnRecordStop");
        DoWidgetAction("OnPlayStop");
    }
    
    void HandlePlay()
    {
        DoWidgetAction("OnPlayStart");
    }
    
    void HandleRecord()
    {
        DoWidgetAction("OnRecordStart");
    }
        
    void StartRewinding()
    {
        if (isFastForwarding_)
            StopFastForwarding();

        if (isRewinding_) // on 2nd, 3rd, etc. press
        {
            speedX5_ = ! speedX5_;
            return;
        }
        
        int playState = DAW::GetPlayState();
        if (playState == 1 || playState == 2 || playState == 5 || playState == 6) // playing or paused or recording or paused whilst recording
            DAW::SetEditCurPos(DAW::GetPlayPosition(), true, false);

        DAW::CSurf_OnStop();
        
        isRewinding_ = true;
        configScrubMode_ = *scrubModePtr_;
        *scrubModePtr_ = 2;
    }
       
    void StartFastForwarding()
    {
        if (isRewinding_)
            StopRewinding();

        if (isFastForwarding_) // on 2nd, 3rd, etc. press
        {
            speedX5_ = ! speedX5_;
            return;
        }
        
        int playState = DAW::GetPlayState();
        if (playState == 1 || playState == 2 || playState == 5 || playState == 6) // playing or paused or recording or paused whilst recording
            DAW::SetEditCurPos(DAW::GetPlayPosition(), true, false);

        DAW::CSurf_OnStop();
        
        isFastForwarding_ = true;
        configScrubMode_ = *scrubModePtr_;
        *scrubModePtr_ = 2;
    }
           
    void AddWidget(Widget *widget)
    {
        if (WDL_NOT_NORMALLY(!widget)) return;
        widgets_.Add(widget);
        widgetsByName_.Insert(widget->GetName().c_str(),widget);
        zoneManager_->AddWidget(widget);
    }
    
    void AddCSIMessageGenerator(CSIMessageGenerator *messageGenerator, const string &message)
    {
        if (WDL_NOT_NORMALLY(!messageGenerator)) { return; }
        CSIMessageGeneratorsByMessage_[message] = messageGenerator;
    }

    Widget *GetWidgetByName(const string &name)
    {
      return widgetsByName_.Get(name.c_str());
    }
    
    void OnPageEnter()
    {
        ForceClear();
        
        DoWidgetAction("OnPageEnter");
    }
    
    void OnPageLeave()
    {
        ForceClear();
        
        DoWidgetAction("OnPageLeave");
    }
    
    void OnInitialization()
    {
        DoWidgetAction("OnInitialization");
    }
    
    
    bool GetShift();
    bool GetOption();
    bool GetControl();
    bool GetAlt();
    bool GetFlip();
    bool GetGlobal();
    bool GetMarker();
    bool GetNudge();
    bool GetZoom();
    bool GetScrub();

    void SetShift(bool value);
    void SetOption(bool value);
    void SetControl(bool value);
    void SetAlt(bool value);
    void SetFlip(bool value);
    void SetGlobal(bool value);
    void SetMarker(bool value);
    void SetNudge(bool value);
    void SetZoom(bool value);
    void SetScrub(bool value);
    
    const WDL_TypedBuf<int> &GetModifiers();
    void ClearModifiers();
    void ClearModifier(const string &modifier);

    void UpdateCurrentActionContextModifiers()
    {
        if (! usesLocalModifiers_)
            GetZoneManager()->UpdateCurrentActionContextModifiers();
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class FeedbackProcessor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
protected:
    double lastDoubleValue_;
    string lastStringValue_;
    rgba_color lastColor_;
    
    Widget  *const widget_;
    
public:
    FeedbackProcessor(Widget *widget) : widget_(widget)
    {
        // protected:
        lastDoubleValue_ = 0.0;
        lastStringValue_ = "";
    }
    virtual ~FeedbackProcessor() {}
    virtual string GetName()  { return "FeedbackProcessor"; }
    Widget *GetWidget() { return widget_; }
    virtual void SetColorValue(rgba_color &color) {}
    virtual void Configure(const WDL_PtrList<ActionContext> &contexts) {}
    virtual void ForceValue(map<string, string> &properties, double value) {}
    virtual void ForceColorValue(const rgba_color &color) {}
    virtual void ForceValue(map<string, string> &properties, const string &value) {}
    virtual void RunDeferredActions() {}
    virtual void UpdateTrackColors() {}
    virtual void ForceUpdateTrackColors() {}
    virtual void SetXTouchDisplayColors(const string &zoneName, const string &colors) {}
    virtual void RestoreXTouchDisplayColors() {}
    virtual void ForceClear() {}
    
    virtual void SetValue(map<string, string> &properties, double value)
    {
        if (lastDoubleValue_ != value)
        {
            lastDoubleValue_ = value;
            ForceValue(properties, value);
        }
    }
    
    virtual void SetValue(map<string, string> &properties, const string &value)
    {
        if (lastStringValue_ != value)
        {
            lastStringValue_ = value;
            ForceValue(properties, value);
        }
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Midi_CSIMessageGenerator : public CSIMessageGenerator
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
protected:
    Midi_CSIMessageGenerator(Widget *widget) : CSIMessageGenerator(widget) {}
    
public:
    virtual ~Midi_CSIMessageGenerator() {}
    virtual void ProcessMidiMessage(const MIDI_event_ex_t *midiMessage) {}
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Midi_FeedbackProcessor : public FeedbackProcessor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
protected:
    Midi_ControlSurface *const surface_ = nullptr;
    
    MIDI_event_ex_t *lastMessageSent_;
    MIDI_event_ex_t *midiFeedbackMessage1_;
    MIDI_event_ex_t *midiFeedbackMessage2_;
    
    Midi_FeedbackProcessor(Midi_ControlSurface *surface, Widget *widget) : FeedbackProcessor(widget), surface_(surface)
    {
        lastMessageSent_ = new MIDI_event_ex_t(0, 0, 0);
        midiFeedbackMessage1_ = new MIDI_event_ex_t(0, 0, 0);
        midiFeedbackMessage2_ = new MIDI_event_ex_t(0, 0, 0);
    }
    
    Midi_FeedbackProcessor(Midi_ControlSurface *surface, Widget *widget, MIDI_event_ex_t *feedback1) : Midi_FeedbackProcessor(surface, widget)
    {
        lastMessageSent_ = new MIDI_event_ex_t(0, 0, 0);
        if (WDL_NOT_NORMALLY(!feedback1)) return;
        midiFeedbackMessage1_ = feedback1;
        midiFeedbackMessage2_ = new MIDI_event_ex_t(0, 0, 0);
    }
    
    Midi_FeedbackProcessor(Midi_ControlSurface *surface, Widget *widget, MIDI_event_ex_t *feedback1, MIDI_event_ex_t *feedback2) :  Midi_FeedbackProcessor(surface, widget)
    {
        lastMessageSent_ = new MIDI_event_ex_t(0, 0, 0);
        if (WDL_NOT_NORMALLY(!feedback1)) return;
        midiFeedbackMessage1_ = feedback1;
        if (WDL_NOT_NORMALLY(!feedback2)) return;
        midiFeedbackMessage2_ = feedback2;
    }
    
    void SendMidiSysExMessage(MIDI_event_ex_t *midiMessage);
    void SendMidiMessage(int first, int second, int third);
    void ForceMidiMessage(int first, int second, int third);

public:
    ~Midi_FeedbackProcessor()
    {
        if (lastMessageSent_ != nullptr)
            delete lastMessageSent_;
        
        if (midiFeedbackMessage1_ != nullptr)
            delete midiFeedbackMessage1_;
        
        if (midiFeedbackMessage2_ != nullptr)
            delete midiFeedbackMessage2_;
    }
    
    virtual string GetName() override { return "Midi_FeedbackProcessor"; }
};

void ReleaseMidiInput(midi_Input *input);
void ReleaseMidiOutput(midi_Output *output);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Midi_ControlSurfaceIO
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    string const name_;
    midi_Input *const midiInput_;
    midi_Output *const midiOutput_;
    
public:
    Midi_ControlSurfaceIO(string name, midi_Input *midiInput, midi_Output *midiOutput) : name_(name), midiInput_(midiInput), midiOutput_(midiOutput) {}

    ~Midi_ControlSurfaceIO()
    {
        if (midiInput_) ReleaseMidiInput(midiInput_);
        if (midiOutput_) ReleaseMidiOutput(midiOutput_);
    }
    
    const string &GetName() { return name_; }
    
    void HandleExternalInput(Midi_ControlSurface *surface);
    
    void SendMidiMessage(MIDI_event_ex_t *midiMessage)
    {
        if (midiOutput_)
            midiOutput_->SendMsg(midiMessage, -1);
    }

    void SendMidiMessage(int first, int second, int third)
    {
        if (midiOutput_)
            midiOutput_->Send(first, second, third, -1);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Midi_ControlSurface : public ControlSurface
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    string const templateFilename_;
    Midi_ControlSurfaceIO *const surfaceIO_;
    map<int, WDL_PtrList<Midi_CSIMessageGenerator>> Midi_CSIMessageGeneratorsByMessage_;

    // special processing for MCU meters
    bool hasMCUMeters_;
    int displayType_;

    void InitializeMCU();
    void InitializeMCUXT();
    
    virtual void InitializeMeters()
    {
        if (hasMCUMeters_)
        {
            if (displayType_ == 0x14)
                InitializeMCU();
            else
                InitializeMCUXT();
        }
    }

public:
    Midi_ControlSurface(Page *page, const string &name, int numChannels, int channelOffset, string templateFilename, string zoneFolder, string fxZoneFolder, Midi_ControlSurfaceIO *surfaceIO);

    virtual ~Midi_ControlSurface()
    {
        for (auto [key, generators] : Midi_CSIMessageGeneratorsByMessage_)
            generators.Empty(true);
    }
    
    void ProcessMidiMessage(const MIDI_event_ex_t *evt);
    virtual void SendMidiSysExMessage(MIDI_event_ex_t *midiMessage) override;
    virtual void SendMidiMessage(int first, int second, int third) override;

    virtual void SetHasMCUMeters(int displayType) override
    {
        hasMCUMeters_ = true;
        displayType_ = displayType;
    }
    
    virtual void HandleExternalInput() override
    {
        surfaceIO_->HandleExternalInput(this);
    }
        
    void AddCSIMessageGenerator(Midi_CSIMessageGenerator *messageGenerator, int message)
    {
        if (WDL_NOT_NORMALLY(!messageGenerator)) return;
        Midi_CSIMessageGeneratorsByMessage_[message].Add(messageGenerator);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class OSC_FeedbackProcessor : public FeedbackProcessor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
protected:
    OSC_ControlSurface *const surface_;
    string const oscAddress_;
    
public:
    OSC_FeedbackProcessor(OSC_ControlSurface *surface, Widget *widget, string oscAddress) : FeedbackProcessor(widget), surface_(surface), oscAddress_(oscAddress) {}
    ~OSC_FeedbackProcessor() {}

    virtual string GetName() override { return "OSC_FeedbackProcessor"; }

    virtual void SetColorValue(rgba_color &color) override;
    virtual void X32SetColorValue(rgba_color &color);
    virtual void ForceValue(map<string, string> &properties, double value) override;
    virtual void ForceValue(map<string, string> &properties, const string &value) override;
    virtual void ForceClear() override;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class OSC_IntFeedbackProcessor : public OSC_FeedbackProcessor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
public:
    OSC_IntFeedbackProcessor(OSC_ControlSurface *surface, Widget *widget, string oscAddress) : OSC_FeedbackProcessor(surface, widget, oscAddress) {}
    ~OSC_IntFeedbackProcessor() {}

    virtual string GetName() override { return "OSC_IntFeedbackProcessor"; }

    virtual void ForceValue(map<string, string> &properties, double value) override;
    virtual void ForceClear() override;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class OSC_ControlSurfaceIO
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    string const name_;
    oscpkt::UdpSocket *inSocket_;
    oscpkt::UdpSocket *outSocket_;
    oscpkt::PacketReader packetReader_;
    oscpkt::PacketWriter packetWriter_;
    double X32HeartBeatRefreshInterval_;
    double X32HeartBeatLastRefreshTime_;
    
public:
    OSC_ControlSurfaceIO(const string &name, const string &receiveOnPort, const string &transmitToPort, const string &transmitToIpAddress);

    const string &GetName() { return name_; }

    void HandleExternalInput(OSC_ControlSurface *surface);
    
    void SendOSCMessage(const string &oscAddress, double value)
    {
        if (outSocket_ != nullptr && outSocket_->isOk())
        {
            oscpkt::Message message;
            message.init(oscAddress).pushFloat((float)value);
            packetWriter_.init().addMessage(message);
            outSocket_->sendPacket(packetWriter_.packetData(), packetWriter_.packetSize());
        }
    }
    
    void SendOSCMessage(const string &oscAddress, int value)
    {
        if (outSocket_ != nullptr && outSocket_->isOk())
        {
            oscpkt::Message message;
            message.init(oscAddress).pushInt32(value);
            packetWriter_.init().addMessage(message);
            outSocket_->sendPacket(packetWriter_.packetData(), packetWriter_.packetSize());
        }
    }
    
    void SendOSCMessage(const string &oscAddress, string value)
    {
        if (outSocket_ != nullptr && outSocket_->isOk())
        {
            oscpkt::Message message;
            message.init(oscAddress).pushStr(value);
            packetWriter_.init().addMessage(message);
            outSocket_->sendPacket(packetWriter_.packetData(), packetWriter_.packetSize());
        }
    }
    
    void SendOSCMessage(const string &value)
    {
        if (outSocket_ != nullptr && outSocket_->isOk())
        {
            oscpkt::Message message;
            message.init(value);
            packetWriter_.init().addMessage(message);
            outSocket_->sendPacket(packetWriter_.packetData(), packetWriter_.packetSize());
        }
    }
    
    void SendX32HeartBeat()
    {
        double currentTime = DAW::GetCurrentNumberOfMilliseconds();

        if (currentTime - X32HeartBeatLastRefreshTime_ > X32HeartBeatRefreshInterval_)
        {
            X32HeartBeatLastRefreshTime_ = currentTime;
            SendOSCMessage("/xremote");
        }
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class OSC_ControlSurface : public ControlSurface
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    string const templateFilename_;
    OSC_ControlSurfaceIO *const surfaceIO_;

public:
    OSC_ControlSurface(Page *page, const string &name, int numChannels, int channelOffset, string templateFilename, string zoneFolder, string fxZoneFolder, OSC_ControlSurfaceIO *surfaceIO);

    virtual ~OSC_ControlSurface() {}
    
    void ProcessOSCMessage(const string &message, double value);
    void SendOSCMessage(OSC_FeedbackProcessor *feedbackProcessor, const string &oscAddress, double value);
    void SendOSCMessage(OSC_FeedbackProcessor *feedbackProcessor, const string &oscAddress, int value);
    void SendOSCMessage(OSC_FeedbackProcessor *feedbackProcessor, const string &oscAddress, const string &value);
    virtual void SendOSCMessage(const string &zoneName) override;
    virtual void SendOSCMessage(const string &zoneName, int value) override;
    virtual void SendOSCMessage(const string &zoneName, double value) override;
    virtual void SendOSCMessage(const string &zoneName, const string &value) override;

    bool IsX32()
    {
        return GetName().find("X32") != string::npos || GetName().find("x32") != string::npos;
    }
    
    virtual void RequestUpdate() override
    {
        ControlSurface::RequestUpdate();

        if (IsX32())
            surfaceIO_->SendX32HeartBeat();
    }

    virtual void HandleExternalInput() override
    {
        surfaceIO_->HandleExternalInput(this);
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class TrackNavigationManager
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    Page *const page_;
    bool followMCP_;
    bool synchPages_;
    bool isScrollLinkEnabled_;
    bool isScrollSynchEnabled_;
    int currentTrackVCAFolderMode_;
    int targetScrollLinkChannel_;
    int trackOffset_;
    int vcaTrackOffset_;
    int folderTrackOffset_;
    int selectedTracksOffset_;
    WDL_PtrList<MediaTrack> tracks_;
    WDL_PtrList<MediaTrack> selectedTracks_;
    
    WDL_PtrList<MediaTrack> vcaTopLeadTracks_;
    MediaTrack *            vcaLeadTrack_;
    WDL_PtrList<MediaTrack> vcaLeadTracks_;
    WDL_PtrList<MediaTrack> vcaSpillTracks_;
    
    WDL_PtrList<MediaTrack> folderTopParentTracks_;
    MediaTrack *            folderParentTrack_;
    WDL_PtrList<MediaTrack> folderParentTracks_;
    WDL_PtrList<MediaTrack> folderSpillTracks_;
    map<MediaTrack*, WDL_PtrList<MediaTrack>> folderDictionary_;

    map<int, Navigator*> trackNavigators_;
    Navigator *const masterTrackNavigator_;
    Navigator *selectedTrackNavigator_;
    Navigator *focusedFXNavigator_;
    
    vector<string> autoModeDisplayNames_;
    
    void ForceScrollLink()
    {
        // Make sure selected track is visble on the control surface
        MediaTrack *selectedTrack = GetSelectedTrack();
        
        if (selectedTrack != nullptr)
        {
            for (auto  [key, navigator] : trackNavigators_)
                if (selectedTrack == navigator->GetTrack())
                    return;
            
            for (int i = 1; i <= GetNumTracks(); i++)
            {
                if (selectedTrack == GetTrackFromId(i))
                {
                    trackOffset_ = i - 1;
                    break;
                }
            }
            
            trackOffset_ -= targetScrollLinkChannel_;
            
            if (trackOffset_ <  0)
                trackOffset_ =  0;
            
            int top = GetNumTracks() - (int)trackNavigators_.size();
            
            if (trackOffset_ >  top)
                trackOffset_ = top;
        }
    }
    
public:
    TrackNavigationManager(Page *page, bool followMCP,  bool synchPages, bool isScrollLinkEnabled, bool isScrollSynchEnabled) :
    page_(page),
    followMCP_(followMCP),
    synchPages_(synchPages),
    isScrollLinkEnabled_(isScrollLinkEnabled),
    isScrollSynchEnabled_(isScrollSynchEnabled),
    masterTrackNavigator_(new MasterTrackNavigator(page_)),
    selectedTrackNavigator_(new SelectedTrackNavigator(page_)),
    focusedFXNavigator_(new FocusedFXNavigator(page_))
    {
        //private:
        currentTrackVCAFolderMode_ = 0;
        targetScrollLinkChannel_ = 0;
        trackOffset_ = 0;
        vcaTrackOffset_ = 0;
        folderTrackOffset_ = 0;
        selectedTracksOffset_ = 0;
        vcaLeadTrack_ = nullptr;
        folderParentTrack_ = nullptr;
        autoModeDisplayNames_ = { "Trim", "Read", "Touch", "Write", "Latch", "LtchPre" };
    }
    ~TrackNavigationManager()
    {
        delete masterTrackNavigator_;
        delete selectedTrackNavigator_;
        delete focusedFXNavigator_;
        
        for (auto [key, navigator] : trackNavigators_)
            delete navigator;
    }
    
    void RebuildTracks();
    void RebuildSelectedTracks();
    void AdjustSelectedTrackBank(int amount);
    bool GetSynchPages() { return synchPages_; }
    bool GetScrollLink() { return isScrollLinkEnabled_; }
    int  GetNumTracks() { return DAW::CSurf_NumTracks(followMCP_); }
    Navigator *GetMasterTrackNavigator() { return masterTrackNavigator_; }
    Navigator *GetSelectedTrackNavigator() { return selectedTrackNavigator_; }
    Navigator *GetFocusedFXNavigator() { return focusedFXNavigator_; }
    
    bool GetIsTrackVisible(MediaTrack *track)
    {
        return DAW::IsTrackVisible(track, followMCP_);
    }
    
    void VCAModeActivated()
    {
        currentTrackVCAFolderMode_ = 1;
    }
    
    void FolderModeActivated()
    {
        currentTrackVCAFolderMode_ = 2;
    }
    
    void SelectedTracksModeActivated()
    {
        currentTrackVCAFolderMode_ = 3;
    }
    
    void VCAModeDeactivated()
    {
        if (currentTrackVCAFolderMode_ == 1)
            currentTrackVCAFolderMode_ = 0;
    }
    
    void FolderModeDeactivated()
    {
        if (currentTrackVCAFolderMode_ == 2)
            currentTrackVCAFolderMode_ = 0;
    }
    
    void SelectedTracksModeDeactivated()
    {
        if (currentTrackVCAFolderMode_ == 3)
            currentTrackVCAFolderMode_ = 0;
    }
    
    string GetCurrentTrackVCAFolderModeDisplay()
    {
        if (currentTrackVCAFolderMode_ == 0)
            return "Track";
        else if (currentTrackVCAFolderMode_ == 1)
            return "VCA";
        else if (currentTrackVCAFolderMode_ == 2)
            return "Folder";
        else if (currentTrackVCAFolderMode_ == 3)
            return "SelectedTracks";
        else
            return "";
    }

    const string &GetAutoModeDisplayName(int modeIndex)
    {
        int globalOverride = DAW::GetGlobalAutomationOverride();

        if (globalOverride > -1) // -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass
            return autoModeDisplayNames_[globalOverride];
        else
            return autoModeDisplayNames_[modeIndex];
    }

    string GetGlobalAutoModeDisplayName()
    {
        int globalOverride = DAW::GetGlobalAutomationOverride();

        if (globalOverride == -1)
            return "NoOverride";
        else if (globalOverride > -1) // -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass
            return autoModeDisplayNames_[globalOverride];
        else
            return "";
    }

    void NextInputMonitorMode(MediaTrack *track)
    {
        // I_RECMON : int  *: record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
        int recMonitorMode = (int)DAW::GetMediaTrackInfo_Value(track,"I_RECMON");

        // I_RECMONITEMS : int  *: monitor items while recording (0=off, 1=on)
        int recMonitorItemMode = (int)DAW::GetMediaTrackInfo_Value(track,"I_RECMONITEMS");

        if (recMonitorMode == 0)
        {
            recMonitorMode = 1;
            recMonitorItemMode = 0;
        }
        else if (recMonitorMode == 1 && recMonitorItemMode == 0)
        {
            recMonitorMode = 2;
            recMonitorItemMode = 0;
        }
        else if (recMonitorMode == 2 && recMonitorItemMode == 0)
        {
            recMonitorMode = 1;
            recMonitorItemMode = 1;
        }
        else if (recMonitorMode == 1 && recMonitorItemMode == 1)
        {
            recMonitorMode = 2;
            recMonitorItemMode = 1;
        }
        else if (recMonitorMode == 2 && recMonitorItemMode == 1)
        {
            recMonitorMode = 0;
            recMonitorItemMode = 0;
        }

        DAW::GetSetMediaTrackInfo(track, "I_RECMON", &recMonitorMode);
        DAW::GetSetMediaTrackInfo(track, "I_RECMONITEMS", &recMonitorItemMode);
    }
    
    string GetCurrentInputMonitorMode(MediaTrack *track)
    {
        // I_RECMON : int  *: record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
        int recMonitorMode = (int)DAW::GetMediaTrackInfo_Value(track,"I_RECMON");

        // I_RECMONITEMS : int  *: monitor items while recording (0=off, 1=on)
        int recMonitorItemMode = (int)DAW::GetMediaTrackInfo_Value(track,"I_RECMONITEMS");

        if (recMonitorMode == 0)
            return "Off";
        else if (recMonitorMode == 1 && recMonitorItemMode == 0)
            return "Input";
        else if (recMonitorMode == 2 && recMonitorItemMode == 0)
            return "Auto";
        else if (recMonitorMode == 1 && recMonitorItemMode == 1)
            return "Input+";
        else if (recMonitorMode == 2 && recMonitorItemMode == 1)
            return "Auto+";
        else
            return "";
    }
    
    WDL_PtrList<MediaTrack> &GetSelectedTracks()
    {
        selectedTracks_.Empty();
        
        for (int i = 0; i < DAW::CountSelectedTracks(); i++)
            selectedTracks_.Add(DAW::GetSelectedTrack(i));
        
        return selectedTracks_;
    }

    void SetTrackOffset(int trackOffset)
    {
        if (isScrollSynchEnabled_)
            trackOffset_ = trackOffset;
    }
    
    void AdjustTrackBank(int amount)
    {
        if (currentTrackVCAFolderMode_ != 0)
            return;

        int numTracks = tracks_.GetSize();
        
        if (numTracks <= (int)trackNavigators_.size())
            return;
       
        trackOffset_ += amount;
        
        if (trackOffset_ <  0)
            trackOffset_ =  0;
        
        int top = numTracks - (int)trackNavigators_.size();
        
        if (trackOffset_ >  top)
            trackOffset_ = top;
        
        if (isScrollSynchEnabled_)
        {
            int offset = trackOffset_;
            
            offset++;
            
            if (MediaTrack *leftmostTrack = DAW::GetTrack(offset))
                DAW::SetMixerScroll(leftmostTrack);
        }
    }
    
    void AdjustVCABank(int amount)
    {
        if (currentTrackVCAFolderMode_ != 1)
            return;

        int numTracks = vcaSpillTracks_.GetSize();
            
        if (numTracks <= (int)trackNavigators_.size())
            return;
       
        vcaTrackOffset_ += amount;
        
        if (vcaTrackOffset_ <  0)
            vcaTrackOffset_ =  0;
        
        int top = numTracks - (int)trackNavigators_.size();
        
        if (vcaTrackOffset_ >  top)
            vcaTrackOffset_ = top;
    }
    
    void AdjustFolderBank(int amount)
    {
        if (currentTrackVCAFolderMode_ != 2)
            return;

        int numTracks = folderSpillTracks_.GetSize();
        
        if (numTracks <= trackNavigators_.size())
            return;
       
        folderTrackOffset_ += amount;
        
        if (folderTrackOffset_ <  0)
            folderTrackOffset_ =  0;
        
        int top = numTracks - (int)trackNavigators_.size();
        
        if (folderTrackOffset_ >  top)
            folderTrackOffset_ = top;
    }
    
    void AdjustSelectedTracksBank(int amount)
    {
        if (currentTrackVCAFolderMode_ != 3)
            return;

        int numTracks = selectedTracks_.GetSize();
       
        if (numTracks <= trackNavigators_.size())
            return;
        
        selectedTracksOffset_ += amount;
        
        if (selectedTracksOffset_ < 0)
            selectedTracksOffset_ = 0;
        
        int top = numTracks - (int)trackNavigators_.size();
        
        if (selectedTracksOffset_ > top)
            selectedTracksOffset_ = top;
    }
    
    Navigator *GetNavigatorForChannel(int channelNum)
    {
        if (trackNavigators_.count(channelNum) < 1)
            trackNavigators_[channelNum] = new TrackNavigator(page_, this, channelNum);
            
        return trackNavigators_[channelNum];
    }
    
    MediaTrack *GetTrackFromChannel(int channelNumber)
    {       
        if (currentTrackVCAFolderMode_ == 0)
        {
            if (channelNumber + trackOffset_ < GetNumTracks() && channelNumber + trackOffset_ < tracks_.GetSize())
                return tracks_.Get(channelNumber + trackOffset_);
            else
                return nullptr;
        }
        else if (currentTrackVCAFolderMode_ == 1)
        {
            if (vcaLeadTrack_ == nullptr)
            {
                if (channelNumber < vcaTopLeadTracks_.GetSize() && DAW::ValidateTrackPtr(vcaTopLeadTracks_.Get(channelNumber)))
                    return vcaTopLeadTracks_.Get(channelNumber);
                else
                    return nullptr;
            }
            else
            {
                if (channelNumber == 0 && vcaSpillTracks_.GetSize() > 0 && DAW::ValidateTrackPtr(vcaSpillTracks_.Get(channelNumber)))
                    return vcaSpillTracks_.Get(channelNumber);
                else if (vcaTrackOffset_ == 0 && channelNumber < vcaSpillTracks_.GetSize() && DAW::ValidateTrackPtr(vcaSpillTracks_.Get(channelNumber)))
                    return vcaSpillTracks_.Get(channelNumber);
                else
                {
                    channelNumber += vcaTrackOffset_;
                    
                    if (channelNumber < vcaSpillTracks_.GetSize() && DAW::ValidateTrackPtr(vcaSpillTracks_.Get(channelNumber)))
                        return vcaSpillTracks_.Get(channelNumber);
                }
            }
        }
        else if (currentTrackVCAFolderMode_ == 2)
        {
            if (folderParentTrack_ == nullptr)
            {
                if (channelNumber < folderTopParentTracks_.GetSize() && DAW::ValidateTrackPtr(folderTopParentTracks_.Get(channelNumber)))
                    return folderTopParentTracks_.Get(channelNumber);
                else
                    return nullptr;
            }
            else
            {
                if (channelNumber == 0 && folderSpillTracks_.GetSize() > 0 && DAW::ValidateTrackPtr(folderSpillTracks_.Get(channelNumber)))
                    return folderSpillTracks_.Get(channelNumber);
                else if (folderTrackOffset_ == 0 && channelNumber < folderSpillTracks_.GetSize() && DAW::ValidateTrackPtr(folderSpillTracks_.Get(channelNumber)))
                    return folderSpillTracks_.Get(channelNumber);
                else
                {
                    channelNumber += folderTrackOffset_;
                    
                    if (channelNumber < folderSpillTracks_.GetSize() && DAW::ValidateTrackPtr(folderSpillTracks_.Get(channelNumber)))
                        return folderSpillTracks_.Get(channelNumber);
                }
            }
        }
        else if (currentTrackVCAFolderMode_ == 3)
        {
            if (channelNumber + selectedTracksOffset_ >= selectedTracks_.GetSize())
                return nullptr;
            else
                return selectedTracks_.Get(channelNumber + selectedTracksOffset_);
        }
        
        return nullptr;
    }
    
    MediaTrack *GetTrackFromId(int trackNumber)
    {
        if (trackNumber <= GetNumTracks())
            return DAW::CSurf_TrackFromID(trackNumber, followMCP_);
        else
            return nullptr;
    }
    
    int GetIdFromTrack(MediaTrack *track)
    {
        return DAW::CSurf_TrackToID(track, followMCP_);
    }
    
    bool GetIsVCASpilled(MediaTrack *track)
    {
        if (vcaLeadTrack_ == nullptr && (DAW::GetTrackGroupMembership(track, "VOLUME_VCA_LEAD") != 0 || DAW::GetTrackGroupMembershipHigh(track, "VOLUME_VCA_LEAD") != 0))
            return true;
        else if (vcaLeadTrack_ == track)
            return true;
        else
            return false;
    }
    
    void ToggleVCASpill(MediaTrack *track)
    {
        if (currentTrackVCAFolderMode_ != 1)
            return;
        
        if (DAW::GetTrackGroupMembership(track, "VOLUME_VCA_LEAD") == 0 && DAW::GetTrackGroupMembershipHigh(track, "VOLUME_VCA_LEAD") == 0)
            return;

        if (vcaLeadTrack_ == track)
        {
            if (vcaLeadTracks_.GetSize() > 0)
            {
                vcaLeadTrack_ = vcaLeadTracks_.Get(vcaLeadTracks_.GetSize() - 1);
                vcaLeadTracks_.Delete(vcaLeadTracks_.GetSize() - 1);
            }
            else
                vcaLeadTrack_ = nullptr;
        }
        else if (vcaLeadTrack_ != nullptr)
        {
            vcaLeadTracks_.Add(vcaLeadTrack_);
            vcaLeadTrack_ = track;
        }
        else
            vcaLeadTrack_ = track;
       
        vcaTrackOffset_ = 0;
    }

    bool GetIsFolderSpilled(MediaTrack *track)
    {
        if (folderTopParentTracks_.Find(track) >= 0)
            return true;
        else if (DAW::GetMediaTrackInfo_Value(track, "I_FOLDERDEPTH") == 1)
            return true;
        else
            return false;
    }

    void ToggleFolderSpill(MediaTrack *track)
    {
        if (currentTrackVCAFolderMode_ != 2)
            return;
        
        if (folderTopParentTracks_.GetSize() == 0)
            return;

        else if (DAW::GetMediaTrackInfo_Value(track, "I_FOLDERDEPTH") != 1)
            return;
        
        if (folderParentTrack_ == track)
        {
            if (folderParentTracks_.GetSize() > 0)
            {
                folderParentTrack_ = folderParentTracks_.Get(folderParentTracks_.GetSize() - 1);
                folderParentTracks_.Delete(folderParentTracks_.GetSize() - 1);
            }
            else
                folderParentTrack_ = nullptr;
        }
        else if (folderParentTrack_ != nullptr)
        {
            folderParentTracks_.Add(folderParentTrack_);
            folderParentTrack_ = track;
        }
        else
            folderParentTrack_ = track;
       
        folderTrackOffset_ = 0;
    }
    
    void ToggleSynchPages()
    {
        synchPages_ = ! synchPages_;
    }
    
    void ToggleScrollLink(int targetChannel)
    {
        targetScrollLinkChannel_ = targetChannel - 1 < 0 ? 0 : targetChannel - 1;
        
        isScrollLinkEnabled_ = ! isScrollLinkEnabled_;
        
        OnTrackSelection();
    }
    
    MediaTrack *GetSelectedTrack()
    {
        if (DAW::CountSelectedTracks() != 1)
            return nullptr;
        else
            return DAW::GetSelectedTrack(0);
    }
    
//  Page only uses the following:
       
    void OnTrackSelection()
    {
        if (isScrollLinkEnabled_ && tracks_.GetSize() > trackNavigators_.size())
            ForceScrollLink();
    }
    
    void OnTrackListChange()
    {
        if (isScrollLinkEnabled_ && tracks_.GetSize() > trackNavigators_.size())
            ForceScrollLink();
    }

    void OnTrackSelectionBySurface(MediaTrack *track)
    {
        if (isScrollLinkEnabled_)
        {
            if (DAW::IsTrackVisible(track, true))
                DAW::SetMixerScroll(track); // scroll selected MCP tracks into view
            
            if (DAW::IsTrackVisible(track, false))
                DAW::SendCommandMessage(40913); // scroll selected TCP tracks into view
        }
    }

    bool GetIsControlTouched(MediaTrack *track, int touchedControl)
    {
        if (track == GetMasterTrackNavigator()->GetTrack())
            return GetIsNavigatorTouched(GetMasterTrackNavigator(), touchedControl);
        
        for (auto  [key, navigator] : trackNavigators_)
            if (track == navigator->GetTrack())
                return GetIsNavigatorTouched(navigator, touchedControl);
 
        if (MediaTrack *selectedTrack = GetSelectedTrack())
             if (track == selectedTrack)
                return GetIsNavigatorTouched(GetSelectedTrackNavigator(), touchedControl);
        
        if (MediaTrack *focusedFXTrack = GetFocusedFXNavigator()->GetTrack())
            if (track == focusedFXTrack)
                return GetIsNavigatorTouched(GetFocusedFXNavigator(), touchedControl);

        return false;
    }
    
    bool GetIsNavigatorTouched(Navigator *navigator,  int touchedControl)
    {
        if (touchedControl == 0)
            return navigator->GetIsVolumeTouched();
        else if (touchedControl == 1)
        {
            if (navigator->GetIsPanTouched() || navigator->GetIsPanLeftTouched())
                return true;
        }
        else if (touchedControl == 2)
        {
            if (navigator->GetIsPanWidthTouched() || navigator->GetIsPanRightTouched())
                return true;
        }

        return false;
    }
    
    void RebuildVCASpill()
    {   
        if (currentTrackVCAFolderMode_ != 1)
            return;
    
        vcaTopLeadTracks_.Empty();
        vcaSpillTracks_.Empty();
        
        bitset<32> leadTrackVCALeaderGroup;
        bitset<32> leadTrackVCALeaderGroupHigh;
        
        if (vcaLeadTrack_ != nullptr)
        {
            leadTrackVCALeaderGroup = DAW::GetTrackGroupMembership(vcaLeadTrack_, "VOLUME_VCA_LEAD");
            leadTrackVCALeaderGroupHigh = DAW::GetTrackGroupMembershipHigh(vcaLeadTrack_, "VOLUME_VCA_LEAD");
            vcaSpillTracks_.Add(vcaLeadTrack_);
        }
        
        // Get Visible Tracks
        for (int i = 1; i <= GetNumTracks(); i++)
        {
            MediaTrack *track = DAW::CSurf_TrackFromID(i, followMCP_);
            
            if (DAW::GetTrackGroupMembership(track, "VOLUME_VCA_LEAD") != 0 && DAW::GetTrackGroupMembership(track, "VOLUME_VCA_FOLLOW") == 0)
                vcaTopLeadTracks_.Add(track);
            
            if (DAW::GetTrackGroupMembershipHigh(track, "VOLUME_VCA_LEAD") != 0 && DAW::GetTrackGroupMembershipHigh(track, "VOLUME_VCA_FOLLOW") == 0)
                vcaTopLeadTracks_.Add(track);
            
            if (vcaLeadTrack_ != nullptr)
            {
                bool isFollower = false;
                
                bitset<32> leadTrackVCAFollowerGroup(DAW::GetTrackGroupMembership(track, "VOLUME_VCA_FOLLOW"));
                bitset<32> leadTrackVCAFollowerGroupHigh(DAW::GetTrackGroupMembershipHigh(track, "VOLUME_VCA_FOLLOW"));

                for (int i = 0; i < 32; i++)
                {
                    if ((leadTrackVCALeaderGroup[i] == 1 && leadTrackVCAFollowerGroup[i] == 1)
                       || (leadTrackVCALeaderGroupHigh[i] == 1 && leadTrackVCAFollowerGroupHigh[i] == 1))
                    {
                        isFollower = true;
                        break;
                    }
                }
                
                if (isFollower)
                    vcaSpillTracks_.Add(track);
            }
        }
    }
    
    void RebuildFolderTracks()
    {
        if (currentTrackVCAFolderMode_ != 2)
            return;
        
        folderTopParentTracks_.Empty();
        folderDictionary_.clear();
        folderSpillTracks_.Empty();
       
        vector<WDL_PtrList<MediaTrack>*> currentDepthTracks;
        
        for (int i = 1; i <= GetNumTracks(); i++)
        {
            MediaTrack *track = DAW::CSurf_TrackFromID(i, followMCP_);

            if (DAW::GetMediaTrackInfo_Value(track, "I_FOLDERDEPTH") == 1)
            {
                if (currentDepthTracks.size() == 0)
                    folderTopParentTracks_.Add(track);
                else
                    currentDepthTracks.back()->Add(track);
                
                folderDictionary_[track].Add(track);
                
                currentDepthTracks.push_back(&folderDictionary_[track]);
            }
            else if (DAW::GetMediaTrackInfo_Value(track, "I_FOLDERDEPTH") == 0 && currentDepthTracks.size() > 0)
            {
                currentDepthTracks.back()->Add(track);
            }
            else if (DAW::GetMediaTrackInfo_Value(track, "I_FOLDERDEPTH") < 0 && currentDepthTracks.size() > 0)
            {
                currentDepthTracks.back()->Add(track);
                
                int folderBackTrack = (int)-DAW::GetMediaTrackInfo_Value(track, "I_FOLDERDEPTH");
                
                for (int i = 0; i < folderBackTrack && currentDepthTracks.size() > 0; i++)
                    currentDepthTracks.pop_back();
            }
        }
        
        if (folderParentTrack_ != nullptr)
            for (int i = 0; i < folderDictionary_[folderParentTrack_].GetSize(); ++i)
                folderSpillTracks_.Add(folderDictionary_[folderParentTrack_].Get(i));
    }
    
    void EnterPage()
    {
        /*
         if (colorTracks_)
         {
         // capture track colors
         for (auto *navigator : trackNavigators_)
         if (MediaTrack *track = DAW::GetTrackFromGUID(navigator->GetTrackGUID(), followMCP_))
         trackColors_[navigator->GetTrackGUID()] = DAW::GetTrackColor(track);
         }
         */
    }
    
    void LeavePage()
    {
        /*
         if (colorTracks_)
         {
         DAW::PreventUIRefresh(1);
         // reset track colors
         for (auto *navigator : trackNavigators_)
         if (MediaTrack *track = DAW::GetTrackFromGUID(navigator->GetTrackGUID(), followMCP_))
         if (trackColors_.count(navigator->GetTrackGUID()) > 0)
         DAW::GetSetMediaTrackInfo(track, "I_CUSTOMCOLOR", &trackColors_[navigator->GetTrackGUID()]);
         DAW::PreventUIRefresh(-1);
         }
         */
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Page
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    string const name_;
    TrackNavigationManager *trackNavigationManager_;
    ModifierManager *modifierManager_;
    WDL_PtrList<ControlSurface> surfaces_;
    
public:
    Page(const string &name, bool followMCP,  bool synchPages, bool isScrollLinkEnabled, bool isScrollSynchEnabled) : name_(name)
    {
        trackNavigationManager_ = new TrackNavigationManager(this, followMCP, synchPages, isScrollLinkEnabled, isScrollSynchEnabled);
        modifierManager_ = new ModifierManager(this);
    }

    ~Page()
    {
        delete trackNavigationManager_;
        delete modifierManager_;
        surfaces_.Empty(true);
    }
        
    string GetName() { return name_; }
    
    ModifierManager *GetModifierManager() { return modifierManager_; }
    
    WDL_PtrList<ControlSurface> &GetSurfaces() { return surfaces_; }
    
    void AddSurface(ControlSurface *surface)
    {
        if (WDL_NOT_NORMALLY(!surface)) { return; }
        surfaces_.Add(surface);
    }
    
    void UpdateCurrentActionContextModifiers()
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->UpdateCurrentActionContextModifiers();
    }
    
    void ForceClear()
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->ForceClear();
    }
    
    void ForceClearTrack(int trackNum)
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->ForceClearTrack(trackNum);
    }
    
    void ForceUpdateTrackColors()
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->ForceUpdateTrackColors();
    }
      
    bool GetTouchState(MediaTrack *track, int touchedControl)
    {
        return trackNavigationManager_->GetIsControlTouched(track, touchedControl);
    }
    
    void OnTrackSelection(MediaTrack *track)
    {
        trackNavigationManager_->OnTrackSelection();
        
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->OnTrackSelection(track);
    }
    
    void OnTrackListChange()
    {
        trackNavigationManager_->OnTrackListChange();
    }
    
    void OnTrackSelectionBySurface(MediaTrack *track)
    {
        trackNavigationManager_->OnTrackSelectionBySurface(track);
        
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->OnTrackSelection(track);
    }
    
    void TrackFXListChanged(MediaTrack *track)
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->TrackFXListChanged(track);
    }
    
    void EnterPage()
    {
        trackNavigationManager_->EnterPage();
        
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->OnPageEnter();
    }
    
    void LeavePage()
    {
        trackNavigationManager_->LeavePage();
        
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->OnPageLeave();
    }
    
    void OnInitialization()
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->OnInitialization();
    }
    
    void SignalStop()
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->HandleStop();
    }
    
    void SignalPlay()
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->HandlePlay();
    }
    
    void SignalRecord()
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->HandleRecord();
    }
            
    void GoHome()
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->GetZoneManager()->GoHome();
    }
    
    void GoAssociatedZone(string name)
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->GetZoneManager()->GoAssociatedZone(name);
    }
    
    void AdjustBank(const string &zoneName, int amount)
    {
        if (zoneName == "Track")
            trackNavigationManager_->AdjustTrackBank(amount);
        else if (zoneName == "VCA")
            trackNavigationManager_->AdjustVCABank(amount);
        else if (zoneName == "Folder")
            trackNavigationManager_->AdjustFolderBank(amount);
        else if (zoneName == "SelectedTracks")
            trackNavigationManager_->AdjustSelectedTracksBank(amount);
        else if (zoneName == "SelectedTrack")
            trackNavigationManager_->AdjustSelectedTrackBank(amount);
        else
            for (int i = 0; i < (int)surfaces_.GetSize(); ++i)
                surfaces_.Get(i)->GetZoneManager()->AdjustBank(zoneName, amount);
    }
    
    void AddZoneFilePath(ControlSurface *originatingSurface, const string &zoneFolder, const string &name, struct CSIZoneInfo info)
    {
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            if (surfaces_.Get(i) != originatingSurface)
                surfaces_.Get(i)->GetZoneManager()->AddZoneFilePath(zoneFolder, name, info);
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Page facade for TrackNavigationManager
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    bool GetSynchPages() { return trackNavigationManager_->GetSynchPages(); }
    bool GetScrollLink() { return trackNavigationManager_->GetScrollLink(); }
    int  GetNumTracks() { return trackNavigationManager_->GetNumTracks(); }
    Navigator *GetMasterTrackNavigator() { return trackNavigationManager_->GetMasterTrackNavigator(); }
    Navigator * GetSelectedTrackNavigator() { return trackNavigationManager_->GetSelectedTrackNavigator(); }
    Navigator * GetFocusedFXNavigator() { return trackNavigationManager_->GetFocusedFXNavigator(); }
    void VCAModeActivated() { trackNavigationManager_->VCAModeActivated(); }
    void VCAModeDeactivated() { trackNavigationManager_->VCAModeDeactivated(); }
    void FolderModeActivated() { trackNavigationManager_->FolderModeActivated(); }
    void FolderModeDeactivated() { trackNavigationManager_->FolderModeDeactivated(); }
    void SelectedTracksModeActivated() { trackNavigationManager_->SelectedTracksModeActivated(); }
    void SelectedTracksModeDeactivated() { trackNavigationManager_->SelectedTracksModeDeactivated(); }
    Navigator * GetNavigatorForChannel(int channelNum) { return trackNavigationManager_->GetNavigatorForChannel(channelNum); }
    MediaTrack *GetTrackFromId(int trackNumber) { return trackNavigationManager_->GetTrackFromId(trackNumber); }
    int GetIdFromTrack(MediaTrack *track) { return trackNavigationManager_->GetIdFromTrack(track); }
    bool GetIsTrackVisible(MediaTrack *track) { return trackNavigationManager_->GetIsTrackVisible(track); }
    bool GetIsVCASpilled(MediaTrack *track) { return trackNavigationManager_->GetIsVCASpilled(track); }
    void ToggleVCASpill(MediaTrack *track) { trackNavigationManager_->ToggleVCASpill(track); }
    bool GetIsFolderSpilled(MediaTrack *track) { return trackNavigationManager_->GetIsFolderSpilled(track); }
    void ToggleFolderSpill(MediaTrack *track) { trackNavigationManager_->ToggleFolderSpill(track); }
    void ToggleScrollLink(int targetChannel) { trackNavigationManager_->ToggleScrollLink(targetChannel); }
    void ToggleSynchPages() { trackNavigationManager_->ToggleSynchPages(); }
    void SetTrackOffset(int offset) { trackNavigationManager_->SetTrackOffset(offset); }
    MediaTrack *GetSelectedTrack() { return trackNavigationManager_->GetSelectedTrack(); }
    void NextInputMonitorMode(MediaTrack *track) { trackNavigationManager_->NextInputMonitorMode(track); }
    const string &GetAutoModeDisplayName(int modeIndex) { return trackNavigationManager_->GetAutoModeDisplayName(modeIndex); }
    string GetGlobalAutoModeDisplayName() { return trackNavigationManager_->GetGlobalAutoModeDisplayName(); }
    string GetCurrentInputMonitorMode(MediaTrack *track) { return trackNavigationManager_->GetCurrentInputMonitorMode(track); }
    const WDL_PtrList<MediaTrack> &GetSelectedTracks() { return trackNavigationManager_->GetSelectedTracks(); }
    
    
    /*
    int repeats = 0;
    
    void Run()
    {
        int start = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
        
        trackNavigationManager_->RebuildTracks();
        trackNavigationManager_->RebuildVCASpill();
        trackNavigationManager_->RebuildFolderTracks();
     
        for (auto surface : surfaces_)
            surface->HandleExternalInput();
        
        for (auto surface : surfaces_)
            surface->RequestUpdate();
        
         repeats++;
         
         if (repeats > 50)
         {
             repeats = 0;
             
             int totalDuration = 0;

             start = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
             trackNavigationManager_->RebuildTracks();
             trackNavigationManager_->RebuildVCASpill();
             trackNavigationManager_->RebuildFolderTracks();
             int duration = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count() - start;
             totalDuration += duration;
             ShowDuration("Rebuild Track/VCA/Folder List", duration);
             
             for (auto surface : surfaces_)
             {
                 start = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
                 surface->HandleExternalInput();
                 duration = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count() - start;
                 totalDuration += duration;
                 ShowDuration(surface->GetName(), "HandleExternalInput", duration);
             }
             
             for (auto surface : surfaces_)
             {
                 start = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
                 surface->RequestUpdate();
                 duration = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count() - start;
                 totalDuration += duration;
                 ShowDuration(surface->GetName(), "Request Update", duration);
             }
             
             char msgBuffer[250];
             
             sprintf(msgBuffer, "Total duration = %d\n\n\n", totalDuration);
             DAW::ShowConsoleMsg(msgBuffer);
         }
    }
    
    
    void ShowDuration(string item, int duration)
    {
        char msgBuffer[250];
        
        sprintf(msgBuffer, "%s - %d microseconds\n", item.c_str(), duration);
        DAW::ShowConsoleMsg(msgBuffer);
    }
    
    void ShowDuration(string surface, string item, int duration)
    {
        char msgBuffer[250];
        
        sprintf(msgBuffer, "%s - %s - %d microseconds\n", surface.c_str(), item.c_str(), duration);
        DAW::ShowConsoleMsg(msgBuffer);
    }
   */

//*
    void Run()
    {
        trackNavigationManager_->RebuildTracks();
        trackNavigationManager_->RebuildVCASpill();
        trackNavigationManager_->RebuildFolderTracks();
        trackNavigationManager_->RebuildSelectedTracks();
        
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->HandleExternalInput();
        
        for (int i = 0; i < surfaces_.GetSize(); ++i)
            surfaces_.Get(i)->RequestUpdate();
    }
//*/
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CSIManager
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
private:
    WDL_PtrList<Midi_ControlSurfaceIO> midiSurfacesIO_;
    WDL_PtrList<OSC_ControlSurfaceIO> oscSurfacesIO_;

    map<string, Action*> actions_;
    map<string, Action*> learnFXActions_;

    WDL_PtrList<Page> pages_;

    int currentPageIndex_;
    bool surfaceInDisplay_;
    bool surfaceRawInDisplay_;
    bool surfaceOutDisplay_;
    bool fxParamsDisplay_;
    bool fxParamsWrite_;

    bool shouldRun_;
    
    // these are offsets to be passed to projectconfig_var_addr() when needed in order to get the actual pointers
    int timeModeOffs_;
    int timeMode2Offs_;
    int measOffsOffs_;
    int timeOffsOffs_; // for a double
    int projectPanModeOffs_;
    
    int projectMetronomePrimaryVolumeOffs_; // for double -- if invalid, use fallbacks
    int projectMetronomeSecondaryVolumeOffs_; // for double -- if invalid, use fallbacks
    
    map<string, map<int, string>> fxParamAliases_;
    map<string, map<int, int>> fxParamSteppedValueCounts_;
    
    map<int, int> baseTickCounts_ ;
    
    void InitActionsDictionary();

    void InitFXParamStepValues();

    double GetPrivateProfileDouble(string key)
    {
        char tmp[512];
        memset(tmp, 0, sizeof(tmp));
        
        DAW::GetPrivateProfileString("REAPER", key.c_str() , "", tmp, sizeof(tmp), DAW::get_ini_file());
        
        return strtod (tmp, NULL);
    }
    
public:
    int csurf_refcnt_;

    CSIManager()
    {
        csurf_refcnt_ = 0;
        // private:
        currentPageIndex_ = 0;
        surfaceInDisplay_ = false;
        surfaceRawInDisplay_ = false;
        surfaceOutDisplay_ = false;
        fxParamsDisplay_ = false;
        fxParamsWrite_ = false;

        shouldRun_ = true;
        
        InitActionsDictionary();

        int size = 0;
        int index = projectconfig_var_getoffs("projtimemode", &size);
        timeModeOffs_ = size==4 ? index : -1;
        
        index = projectconfig_var_getoffs("projtimemode2", &size);
        timeMode2Offs_ = size==4 ? index : -1;
        
        index = projectconfig_var_getoffs("projmeasoffs", &size);
        measOffsOffs_ = size==4 ? index : - 1;
        
        index = projectconfig_var_getoffs("projtimeoffs", &size);
        timeOffsOffs_ = size==8 ? index : -1;
        
        index = projectconfig_var_getoffs("panmode", &size);
        projectPanModeOffs_ = size==4 ? index : -1;

        // these are supported by ~7.10+, previous versions we fallback to get_config_var() on-demand
        index = projectconfig_var_getoffs("projmetrov1", &size);
        projectMetronomePrimaryVolumeOffs_ = size==8 ? index : -1;

        index = projectconfig_var_getoffs("projmetrov2", &size);
        projectMetronomeSecondaryVolumeOffs_ = size==8 ? index : -1;
        
        static const int stepSizes[]  = { 2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 };
        static const int tickCounts[] = { 250, 235, 220, 205, 190, 175, 160, 145, 130, 115, 100, 90, 80, 70, 60, 50, 45, 40, 35, 30, 25, 20, 20, 20 };
        
        for (int i = 0; i < NUM_ELEM(stepSizes); i++)
            baseTickCounts_[stepSizes[i]] = tickCounts[i];
        
        //GenerateX32SurfaceFile();
    }

    ~CSIManager()
    {
        midiSurfacesIO_.Empty(true);
        
        oscSurfacesIO_.Empty(true);
        
        for (auto [key, action] : actions_)
            delete action;

        for (auto [key, action] : learnFXActions_)
            delete action;
        
        pages_.Empty(true);
    }
    
    void Shutdown()
    {
        fxParamsDisplay_ = false;
        surfaceInDisplay_ = false;
        surfaceOutDisplay_ = false;
       
        // GAW -- IMPORTANT
        
        // We want to stop polling
        shouldRun_ = false;
        
        // Zero out all Widgets before shutting down
        if (pages_.Get(currentPageIndex_))
            pages_.Get(currentPageIndex_)->ForceClear();
    }
    
    void Init();
    
    void ToggleSurfaceInDisplay() { surfaceInDisplay_ = ! surfaceInDisplay_;  }
    void ToggleSurfaceRawInDisplay() { surfaceRawInDisplay_ = ! surfaceRawInDisplay_;  }
    void ToggleSurfaceOutDisplay() { surfaceOutDisplay_ = ! surfaceOutDisplay_;  }
    void ToggleFXParamsDisplay() { fxParamsDisplay_ = ! fxParamsDisplay_;  }
    void ToggleFXParamsWrite() { fxParamsWrite_ = ! fxParamsWrite_;  }

    bool GetSurfaceInDisplay() { return surfaceInDisplay_;  }
    bool GetSurfaceRawInDisplay() { return surfaceRawInDisplay_;  }
    bool GetSurfaceOutDisplay() { return surfaceOutDisplay_;  }
    
    double GetFaderMaxDB() { return GetPrivateProfileDouble("slidermaxv"); }
    double GetFaderMinDB() { return GetPrivateProfileDouble("sliderminv"); }
    double GetVUMaxDB() { return GetPrivateProfileDouble("vumaxvol"); }
    double GetVUMinDB() { return GetPrivateProfileDouble("vuminvol"); }
    
    int *GetTimeModePtr() { return (int *) projectconfig_var_addr(NULL,timeModeOffs_); }
    int *GetTimeMode2Ptr() { return (int *) projectconfig_var_addr(NULL,timeMode2Offs_); }
    int *GetMeasOffsPtr() { return (int *) projectconfig_var_addr(NULL,measOffsOffs_); }
    double *GetTimeOffsPtr() { return (double *) projectconfig_var_addr(NULL,timeOffsOffs_); }
    int GetProjectPanMode() { int *p = (int *) projectconfig_var_addr(NULL,projectPanModeOffs_); return p ? *p : 0; }
   
    double *GetMetronomePrimaryVolumePtr()
    {
      void *ret = projectconfig_var_addr(NULL,projectMetronomePrimaryVolumeOffs_);
      if (ret) return (double *)ret;
      // REAPER 7.09 and earlier require this:
      int size=0;
      ret = get_config_var("projmetrov1", &size);
      if (size==8) return (double *)ret;
      return NULL;
    }
    double *GetMetronomeSecondaryVolumePtr() 
    { 
      void *ret = projectconfig_var_addr(NULL,projectMetronomeSecondaryVolumeOffs_);
      if (ret) return (double *)ret;
      // REAPER 7.09 and earlier require this:
      int size=0;
      ret = get_config_var("projmetrov2", &size);
      if (size==8) return (double *)ret;
      return NULL;
    }
    
    int GetBaseTickCount(int stepCount)
    {
        if (baseTickCounts_.count(stepCount) > 0)
            return baseTickCounts_[stepCount];
        else
            return baseTickCounts_[(int)baseTickCounts_.size() - 1];
    }
    
    void Speak(string phrase)
    {
        const void (*osara_outputMessage)(const char *message) = nullptr;
    
        osara_outputMessage = (decltype(osara_outputMessage))plugin_getapi("osara_outputMessage");

        if (osara_outputMessage)
            osara_outputMessage(phrase.c_str());
    }
    
    ActionContext *GetActionContext(const string &actionName, Widget *widget, Zone *zone, const vector<string> &params)
    {
        if (actions_.count(actionName) > 0)
            return new ActionContext(actions_[actionName], widget, zone, params);
        else
            return new ActionContext(actions_["NoAction"], widget, zone, params);
    }

    ActionContext *GetActionContext(const string &actionName, Widget *widget, Zone *zone, int paramIndex)
    {
        if (actions_.count(actionName) > 0)
            return new ActionContext(actions_[actionName], widget, zone, paramIndex);
        else
            return new ActionContext(actions_["NoAction"], widget, zone, paramIndex);
    }

    ActionContext *GetActionContext(const string &actionName, Widget *widget, Zone *zone, const string &stringParam)
    {
        if (actions_.count(actionName) > 0)
            return new ActionContext(actions_[actionName], widget, zone, stringParam);
        else
            return new ActionContext(actions_["NoAction"], widget, zone, stringParam);
    }

    ActionContext *GetLearnFXActionContext(const string &actionName, Widget *widget, Zone *zone, const vector<string> &params)
    {
        if (learnFXActions_.count(actionName) > 0)
            return new ActionContext(learnFXActions_[actionName], widget, zone, params);
        else
            return new ActionContext(actions_["NoAction"], widget, zone, params);
    }

    void OnTrackSelection(MediaTrack *track)
    {
        if (pages_.Get(currentPageIndex_))
            pages_.Get(currentPageIndex_)->OnTrackSelection(track);
    }
    
    void OnTrackListChange()
    {
        if (pages_.Get(currentPageIndex_))
            pages_.Get(currentPageIndex_)->OnTrackListChange();
    }
    
    void NextTimeDisplayMode()
    {
        int *tmodeptr = GetTimeMode2Ptr();
        if (tmodeptr && *tmodeptr>=0)
        {
            (*tmodeptr)++;
            if ((*tmodeptr)>5)
                (*tmodeptr)=0;
        }
        else
        {
            tmodeptr = GetTimeModePtr();
            
            if (tmodeptr)
            {
                (*tmodeptr)++;
                if ((*tmodeptr)>5)
                    (*tmodeptr)=0;
            }
        }
    }
    
    void SetTrackOffset(int offset)
    {
        if (pages_.Get(currentPageIndex_))
            pages_.Get(currentPageIndex_)->SetTrackOffset(offset);
    }
    
    void AdjustBank(Page *sendingPage, string zoneName, int amount)
    {
        if (! sendingPage->GetSynchPages())
            sendingPage->AdjustBank(zoneName, amount);
        else
            for (int i = 0; i < pages_.GetSize(); ++i)
                if (pages_.Get(i)->GetSynchPages())
                    pages_.Get(i)->AdjustBank(zoneName, amount);
    }
       
    void NextPage()
    {
        if (pages_.Get(currentPageIndex_))
        {
            pages_.Get(currentPageIndex_)->LeavePage();
            currentPageIndex_ = currentPageIndex_ == pages_.GetSize() - 1 ? 0 : (currentPageIndex_+1);
            DAW::SetProjExtState(0, "CSI", "PageIndex", to_string(currentPageIndex_).c_str());
            if (WDL_NORMALLY(pages_.Get(currentPageIndex_)))
                pages_.Get(currentPageIndex_)->EnterPage();
        }
    }
    
    void GoToPage(string pageName)
    {
        for (int i = 0; i < pages_.GetSize(); i++)
        {
            if (pages_.Get(i)->GetName() == pageName)
            {
                if (WDL_NORMALLY(pages_.Get(currentPageIndex_)))
                    pages_.Get(currentPageIndex_)->LeavePage();
                currentPageIndex_ = i;
                if (WDL_NORMALLY(pages_.Get(currentPageIndex_)))
                {
                    DAW::SetProjExtState(0, "CSI", "PageIndex", to_string(currentPageIndex_).c_str());
                    pages_.Get(currentPageIndex_)->EnterPage();
                }
                break;
            }
        }
    }
    
    bool GetTouchState(MediaTrack *track, int touchedControl)
    {
        if (pages_.Get(currentPageIndex_))
            return pages_.Get(currentPageIndex_)->GetTouchState(track, touchedControl);
        else
            return false;
    }
    
    void TrackFXListChanged(MediaTrack *track)
    {
        for (int i = 0; i < pages_.GetSize(); ++i)
            pages_.Get(i)->TrackFXListChanged(track);
        
        if (fxParamsDisplay_ || fxParamsWrite_)
        {
            char fxName[BUFSZ];
            string fxParamName;
            
            ofstream fxFile;
            
            for (int i = 0; i < DAW::TrackFX_GetCount(track); i++)
            {
                DAW::TrackFX_GetFXName(track, i, fxName, sizeof(fxName));
                
                if (fxParamsDisplay_)
                    DAW::ShowConsoleMsg(("Zone \"" + string(fxName) + "\"").c_str());
                
                if (fxParamsWrite_)
                {
                    string fxNameNoBadChars(fxName);
                    fxNameNoBadChars = regex_replace(fxNameNoBadChars, regex(s_BadFileChars), "_");

                    fxFile.open(string(DAW::GetResourcePath()) + "/CSI/Zones/ZoneRawFXFiles/" + fxNameNoBadChars + ".txt");
                    
                    if (fxFile.is_open())
                        fxFile << "Zone \"" + string(fxName) + "\"\n";
                }

                for (int j = 0; j < DAW::TrackFX_GetNumParams(track, i); j++)
                {
                    fxParamName = DAW::TrackFX_GetParamName(track, i, j);

                    if (fxParamsDisplay_)
                        DAW::ShowConsoleMsg(("\n\tFXParam " + to_string(j) + " \"" + string(fxParamName) + "\"").c_str());
  
                    if (fxParamsWrite_ && fxFile.is_open())
                        fxFile <<  "\tFXParam " + to_string(j) + " \"" + string(fxParamName)+ "\"\n";
                        
                    /* step sizes
                    double stepOut = 0;
                    double smallstepOut = 0;
                    double largestepOut = 0;
                    bool istoggleOut = false;
                    TrackFX_GetParameterStepSizes(track, i, j, &stepOut, &smallstepOut, &largestepOut, &istoggleOut);

                    DAW::ShowConsoleMsg(("\n\n" + to_string(j) + " - \"" + string(fxParamName) + "\"\t\t\t\t Step = " +  to_string(stepOut) + " Small Step = " + to_string(smallstepOut)  + " LargeStep = " + to_string(largestepOut)  + " Toggle Out = " + (istoggleOut == 0 ? "false" : "true")).c_str());
                    */
                }
                
                if (fxParamsDisplay_)
                    DAW::ShowConsoleMsg("\nZoneEnd\n\n");

                if (fxParamsWrite_ && fxFile.is_open())
                {
                    fxFile << "ZoneEnd";
                    fxFile.close();
                }
            }
        }
    }
    
    const string &GetTCPFXParamName(MediaTrack *track, int fxIndex, int paramIndex)
    {
        char fxName[BUFSZ];
        DAW::TrackFX_GetNamedConfigParm(track, fxIndex, "fx_name", fxName, sizeof(fxName));

        string fxParamName = DAW::TrackFX_GetParamName(track, fxIndex, paramIndex);
        
        fxParamAliases_[fxName][paramIndex] = fxParamName;

        return fxParamAliases_[fxName][paramIndex];
    }
    
    void SetSteppedValueCount(const string &fxName, int paramIndex, int steppedValuecount)
    {
        fxParamSteppedValueCounts_[fxName][paramIndex] = steppedValuecount;
    }
    
    bool HaveFXSteppedValuesBeenCalculated(string fxName)
    {
        if (fxParamSteppedValueCounts_.count(fxName) > 0)
            return true;
        else
            return false;
    }
    
    int GetSteppedValueCount(const string &fxName, int paramIndex)
    {
        if (fxParamSteppedValueCounts_.count(fxName) > 0 && fxParamSteppedValueCounts_[fxName].count(paramIndex) > 0)
            return fxParamSteppedValueCounts_[fxName][paramIndex];
        else
            return  0;
    }
    
    //int repeats = 0;
    
    void Run()
    {
        //int start = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
        
        if (shouldRun_ && pages_.Get(currentPageIndex_))
            pages_.Get(currentPageIndex_)->Run();
        /*
         repeats++;
         
         if (repeats > 50)
         {
         repeats = 0;
         
         int duration = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count() - start;
         
         char msgBuffer[250];
         
         sprintf(msgBuffer, "%d microseconds\n", duration);
         DAW::ShowConsoleMsg(msgBuffer);
         }
        */
    }
    
    /*
    void GenerateX32SurfaceFile()
    {
        vector<vector<string>> generalWidgets = {   {"MasterFader", "/main/st/mix/fader"},
                                                    {"OtherWidget", "other/widget/"} };
        
        vector<vector<string>> channelWidgets = {   {"Fader", "/ch/|/mix/fader"},
                                                    {"Mute", "/ch/|/mix/mute"},
                                                    {"Solo", "/ch/|/mix/solo"},
                                                    {"Select", "/ch/|/mix/select"} };
       
        ofstream X32File(string(DAW::GetResourcePath()) + "/CSI/Zones/ZoneRawFXFiles/" + "X32.ost");

        if (X32File.is_open())
        {
            for (int i = 0; i < generalWidgets.size(); i++)
            {
                X32File << "Widget " + generalWidgets[i][0]  + "\n";
                
                X32File << "\tControl " + generalWidgets[i][1] + "\n";
                
                X32File << "\tFB_Processor " + generalWidgets[i][1] + "\n";

                X32File << "WidgetEnd\n\n";
            }

            for (int i = 0; i < channelWidgets.size(); i++)
            {
                for (int j = 0; j < 32; j++)
                {
                    string numStr = to_string(j + 1);
             
                    X32File << "Widget " + channelWidgets[i][0] + numStr + "\n";
                    
                    if (numStr.length() < 2)
                       numStr = "0" + numStr;
                    
                    string OSCMessage = regex_replace(channelWidgets[i][1], regex("[|]"), numStr);

                    X32File << "\tControl " + OSCMessage + "\n";

                    X32File << "\tFB_Processor " + OSCMessage + "\n";

                    X32File << "WidgetEnd\n\n";
                }
            }
        }
    }
    */
    
};

/*
 int start = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
 
 
 // code you wish to time goes here
 // code you wish to time goes here
 // code you wish to time goes here
 // code you wish to time goes here
 // code you wish to time goes here
 // code you wish to time goes here
 
 
 
 int duration = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count() - start;
 
 char msgBuffer[250];
 
 sprintf(msgBuffer, "%d microseconds\n", duration);
 DAW::ShowConsoleMsg(msgBuffer);
 
 */

#endif /* control_surface_integrator.h */
